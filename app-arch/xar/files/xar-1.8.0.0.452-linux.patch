--- a/configure.ac
+++ b/configure.ac
@@ -199,7 +199,16 @@
 
 AC_CHECK_MEMBERS([struct statfs.f_fstypename],,,[#include <sys/types.h>
 #include <sys/param.h>
-#include <sys/mount.h>])
+#include <sys/mount.h>
+#include <sys/vfs.h>])
+AC_CHECK_MEMBERS([struct statfs.f_iosize],,,[#include <sys/types.h>
+#include <sys/param.h>
+#include <sys/mount.h>
+#include <sys/vfs.h>])
+AC_CHECK_MEMBERS([struct statfs.f_bsize],,,[#include <sys/types.h>
+#include <sys/param.h>
+#include <sys/mount.h>
+#include <sys/vfs.h>])
 AC_CHECK_MEMBERS([struct statvfs.f_fstypename],,,[#include <sys/statvfs.h>])
 AC_CHECK_MEMBERS([struct stat.st_flags])
 
--- a/lib/util.c
+++ b/lib/util.c
@@ -40,6 +40,7 @@
 #include <sys/types.h>
 #include <sys/mount.h>
 #include <sys/param.h>
+#include <sys/vfs.h>
 #include <arpa/inet.h>
 #include <string.h>
 #include <unistd.h>
@@ -467,6 +467,14 @@
 	return tmp;
 }
 
+#ifndef HAVE_STRUCT_STATFS_F_IOSIZE
+# ifdef HAVE_STRUCT_STATFS_F_BSIZE
+#  define f_iosize f_bsize
+# else
+#  error need a field to get optimal transfer block size
+# endif
+#endif
+
 size_t xar_optimal_io_size_at_path(const char *path)
 {
 	// Start at 1MiB
@@ -491,6 +491,7 @@
 			fs_iosize = optimal_rsize;
 		}
 		
+#ifdef MNT_LOCAL
 		// If we're a remote filesystem, never let us go below the optimal size above of 1MiB
 		// NFS is horrible and lies that the optimal size is 512 bytes.
 		// Whereas SMB in my testing returns 7MiBs (far more practicle)
@@ -503,6 +504,7 @@
 			}
 		}
 		else
+#endif
 		{
 			optimal_rsize = fs_iosize;
 		}
--- a/include/config.h.in
+++ b/include/config.h.in
@@ -15,6 +15,8 @@
 #undef HAVE_STRUCT_STAT_ST_FLAGS
 #undef HAVE_STRUCT_STATVFS_F_FSTYPENAME
 #undef HAVE_STRUCT_STATFS_F_FSTYPENAME
+#undef HAVE_STRUCT_STATFS_F_IOSIZE
+#undef HAVE_STRUCT_STATFS_F_BSIZE
 #undef HAVE_SYS_ACL_H
 #undef HAVE_LIBUTIL_H
 #undef HAVE_LIBPTHREAD

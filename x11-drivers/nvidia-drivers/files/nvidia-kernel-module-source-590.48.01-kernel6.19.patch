https://bugs.gentoo.org/970010
--- a/kernel-module-source/kernel-open/nvidia-uvm/uvm_hmm.c
+++ b/kernel-module-source/kernel-open/nvidia-uvm/uvm_hmm.c
@@ -57,4 +57,5 @@
 #include <linux/memremap.h>
 #include <linux/wait.h>
+#include <linux/version.h>
 
 #include "uvm_common.h"
@@ -2141,5 +2142,9 @@
         UVM_ASSERT(!page_count(dpage));
         UVM_ASSERT(!dpage->zone_device_data);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 19, 0)
+        zone_device_page_init(dpage, page_pgmap(dpage), 0);
+#else
         zone_device_page_init(dpage);
+#endif
         dpage->zone_device_data = gpu_chunk;
         atomic64_inc(&va_block->hmm.va_space->hmm.allocated_page_count);
--- a/kernel-module-source/kernel-open/nvidia-uvm/uvm_pmm_gpu.c
+++ b/kernel-module-source/kernel-open/nvidia-uvm/uvm_pmm_gpu.c
@@ -178,4 +178,6 @@
 #include "uvm_linux.h"
 
+#include <linux/version.h>
+
 #if defined(CONFIG_PCI_P2PDMA) && defined(NV_STRUCT_PAGE_HAS_ZONE_DEVICE_DATA)
 #include <linux/pci-p2pdma.h>
@@ -3000,6 +3002,12 @@
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 19, 0)
+static void devmem_folio_free(struct folio *folio)
+{
+    struct page *page = &folio->page;
+#else
 static void devmem_page_free(struct page *page)
 {
+#endif
     uvm_gpu_chunk_t *chunk = uvm_pmm_devmem_page_to_chunk(page);
     uvm_gpu_t *gpu = uvm_gpu_chunk_get_gpu(chunk);
@@ -3061,5 +3069,9 @@
 static const struct dev_pagemap_ops uvm_pmm_devmem_ops =
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 19, 0)
+    .folio_free = devmem_folio_free,
+#else
     .page_free = devmem_page_free,
+#endif
     .migrate_to_ram = devmem_fault_entry,
 };
@@ -3149,6 +3161,12 @@
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 19, 0)
+static void device_p2p_folio_free(struct folio *folio)
+{
+    struct page *page = &folio->page;
+#else
 static void device_p2p_page_free(struct page *page)
 {
+#endif
     uvm_device_p2p_mem_t *p2p_mem = page->zone_device_data;
 
@@ -3159,12 +3177,24 @@
 
 #if UVM_CDMM_PAGES_SUPPORTED()
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 19, 0)
+static void device_coherent_folio_free(struct folio *folio)
+{
+    device_p2p_folio_free(folio);
+}
+#else
 static void device_coherent_page_free(struct page *page)
 {
     device_p2p_page_free(page);
 }
+#endif
 
 static const struct dev_pagemap_ops uvm_device_coherent_pgmap_ops =
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 19, 0)
+    .folio_free = device_coherent_folio_free,
+#else
     .page_free = device_coherent_page_free,
+#endif
 };
 
@@ -3303,5 +3333,9 @@
 static const struct dev_pagemap_ops uvm_device_p2p_pgmap_ops =
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 19, 0)
+    .folio_free = device_p2p_folio_free,
+#else
     .page_free = device_p2p_page_free,
+#endif
 };
 

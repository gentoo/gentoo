commit 733969ac1917f02923e2a5869a8e14a582e0ba2e
Author: Igor V. Kovalenko <igor.v.kovalenko@gmail.com>
Date:   Sat Sep 25 13:22:09 2021 +0300

    socket-server: Move systemd socket activation code to pulsecore
    
    There is no need to support server sockets in client library. Move all related
    code and tcp-wrappers dependency to pulsecore library.
    
    Part-of: <https://gitlab.freedesktop.org/pulseaudio/pulseaudio/-/merge_requests/640>

diff --git a/src/meson.build b/src/meson.build
index e2860811b..59a9b16bf 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -57,7 +57,6 @@ libpulsecommon_sources = [
   'pulsecore/shm.c',
   'pulsecore/bitset.c',
   'pulsecore/socket-client.c',
-  'pulsecore/socket-server.c',
   'pulsecore/socket-util.c',
   'pulsecore/strbuf.c',
   'pulsecore/strlist.c',
@@ -136,7 +135,6 @@ libpulsecommon_headers = [
   'pulsecore/shm.h',
   'pulsecore/bitset.h',
   'pulsecore/socket-client.h',
-  'pulsecore/socket-server.h',
   'pulsecore/socket-util.h',
   'pulsecore/strbuf.h',
   'pulsecore/strlist.h',
@@ -200,7 +198,7 @@ libpulsecommon = shared_library('pulsecommon-' + pa_version_major_minor,
     libm_dep, thread_dep, dl_dep, shm_dep, iconv_dep, sndfile_dep, dbus_dep,
     x11_dep, libsystemd_dep, glib_dep.partial_dependency(compile_args: true),
     gtk_dep.partial_dependency(compile_args: true), asyncns_dep, libintl_dep,
-    platform_dep, tcpwrap_dep, platform_socket_dep, execinfo_dep,
+    platform_dep, platform_socket_dep, execinfo_dep,
   ],
   implicit_include_directories : false)
 
diff --git a/src/pulsecore/meson.build b/src/pulsecore/meson.build
index d7f9ef2cf..b30264b3a 100644
--- a/src/pulsecore/meson.build
+++ b/src/pulsecore/meson.build
@@ -44,6 +44,7 @@ libpulsecore_sources = [
   'sink.c',
   'sink-input.c',
   'sioman.c',
+  'socket-server.c',
   'sound-file-stream.c',
   'sound-file.c',
   'source.c',
@@ -101,6 +102,7 @@ libpulsecore_headers = [
   'sink-input.h',
   'sink.h',
   'sioman.h',
+  'socket-server.h',
   'sound-file-stream.h',
   'sound-file.h',
   'source-output.h',
@@ -222,7 +224,7 @@ libpulsecore = shared_library('pulsecore-' + pa_version_major_minor,
   install_rpath : privlibdir,
   install_dir : privlibdir,
   link_with : libpulsecore_simd_lib,
-  dependencies : [libm_dep, libpulsecommon_dep, ltdl_dep, shm_dep, sndfile_dep, database_dep, dbus_dep, libatomic_ops_dep, orc_dep, samplerate_dep, soxr_dep, speex_dep, x11_dep, libintl_dep, platform_dep, platform_socket_dep,],
+  dependencies : [libm_dep, libpulsecommon_dep, ltdl_dep, shm_dep, sndfile_dep, database_dep, dbus_dep, libatomic_ops_dep, orc_dep, samplerate_dep, soxr_dep, speex_dep, x11_dep, libsystemd_dep, libintl_dep, platform_dep, tcpwrap_dep, platform_socket_dep,],
   implicit_include_directories : false)
 
 libpulsecore_dep = declare_dependency(link_with: libpulsecore)
diff --git a/src/pulsecore/socket-server.c b/src/pulsecore/socket-server.c
index 13d8a99f7..b13012b6d 100644
--- a/src/pulsecore/socket-server.c
+++ b/src/pulsecore/socket-server.c
@@ -642,3 +642,83 @@ char *pa_socket_server_get_address(pa_socket_server *s, char *c, size_t l) {
             return NULL;
     }
 }
+
+#ifdef HAVE_SYS_UN_H
+
+int pa_unix_socket_is_stale(const char *fn) {
+    struct sockaddr_un sa;
+    int fd = -1, ret = -1;
+
+    pa_assert(fn);
+
+    if ((fd = pa_socket_cloexec(PF_UNIX, SOCK_STREAM, 0)) < 0) {
+        pa_log("socket(): %s", pa_cstrerror(errno));
+        goto finish;
+    }
+
+    sa.sun_family = AF_UNIX;
+    strncpy(sa.sun_path, fn, sizeof(sa.sun_path)-1);
+    sa.sun_path[sizeof(sa.sun_path) - 1] = 0;
+
+    if (connect(fd, (struct sockaddr*) &sa, sizeof(sa)) < 0) {
+#if !defined(OS_IS_WIN32)
+        if (errno == ECONNREFUSED)
+            ret = 1;
+#else
+        if (WSAGetLastError() == WSAECONNREFUSED || WSAGetLastError() == WSAEINVAL)
+            ret = 1;
+#endif
+    } else
+        ret = 0;
+
+finish:
+    if (fd >= 0)
+        pa_close(fd);
+
+    return ret;
+}
+
+int pa_unix_socket_remove_stale(const char *fn) {
+    int r;
+
+    pa_assert(fn);
+
+#ifdef HAVE_SYSTEMD_DAEMON
+    {
+        int n = sd_listen_fds(0);
+        if (n > 0) {
+            for (int i = 0; i < n; ++i) {
+                if (sd_is_socket_unix(SD_LISTEN_FDS_START + i, SOCK_STREAM, 1, fn, 0) > 0) {
+                    /* This is a socket activated socket, therefore do not consider
+                    * it stale. */
+                    return 0;
+                }
+            }
+        }
+    }
+#endif
+
+    if ((r = pa_unix_socket_is_stale(fn)) < 0)
+        return errno != ENOENT ? -1 : 0;
+
+    if (!r)
+        return 0;
+
+    /* Yes, here is a race condition. But who cares? */
+    if (unlink(fn) < 0)
+        return -1;
+
+    return 0;
+}
+
+#else /* HAVE_SYS_UN_H */
+
+int pa_unix_socket_is_stale(const char *fn) {
+    return -1;
+}
+
+int pa_unix_socket_remove_stale(const char *fn) {
+    return -1;
+}
+
+#endif /* HAVE_SYS_UN_H */
diff --git a/src/pulsecore/socket-server.h b/src/pulsecore/socket-server.h
index 0793baf44..b1f093921 100644
--- a/src/pulsecore/socket-server.h
+++ b/src/pulsecore/socket-server.h
@@ -50,4 +50,7 @@ void pa_socket_server_set_callback(pa_socket_server*s, pa_socket_server_on_conne
 
 char *pa_socket_server_get_address(pa_socket_server *s, char *c, size_t l);
 
+int pa_unix_socket_is_stale(const char *fn);
+int pa_unix_socket_remove_stale(const char *fn);
+
 #endif
diff --git a/src/pulsecore/socket-util.c b/src/pulsecore/socket-util.c
index f2c8c3c31..4ede0439e 100644
--- a/src/pulsecore/socket-util.c
+++ b/src/pulsecore/socket-util.c
@@ -50,9 +50,6 @@
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
-#ifdef HAVE_SYSTEMD_DAEMON
-#include <systemd/sd-daemon.h>
-#endif
 
 #include <pulsecore/core-error.h>
 #include <pulsecore/core-util.h>
@@ -221,86 +218,6 @@ int pa_socket_set_sndbuf(int fd, size_t l) {
     return 0;
 }
 
-#ifdef HAVE_SYS_UN_H
-
-int pa_unix_socket_is_stale(const char *fn) {
-    struct sockaddr_un sa;
-    int fd = -1, ret = -1;
-
-    pa_assert(fn);
-
-    if ((fd = pa_socket_cloexec(PF_UNIX, SOCK_STREAM, 0)) < 0) {
-        pa_log("socket(): %s", pa_cstrerror(errno));
-        goto finish;
-    }
-
-    sa.sun_family = AF_UNIX;
-    strncpy(sa.sun_path, fn, sizeof(sa.sun_path)-1);
-    sa.sun_path[sizeof(sa.sun_path) - 1] = 0;
-
-    if (connect(fd, (struct sockaddr*) &sa, sizeof(sa)) < 0) {
-#if !defined(OS_IS_WIN32)
-        if (errno == ECONNREFUSED)
-            ret = 1;
-#else
-        if (WSAGetLastError() == WSAECONNREFUSED || WSAGetLastError() == WSAEINVAL)
-            ret = 1;
-#endif
-    } else
-        ret = 0;
-
-finish:
-    if (fd >= 0)
-        pa_close(fd);
-
-    return ret;
-}
-
-int pa_unix_socket_remove_stale(const char *fn) {
-    int r;
-
-    pa_assert(fn);
-
-#ifdef HAVE_SYSTEMD_DAEMON
-    {
-        int n = sd_listen_fds(0);
-        if (n > 0) {
-            for (int i = 0; i < n; ++i) {
-                if (sd_is_socket_unix(SD_LISTEN_FDS_START + i, SOCK_STREAM, 1, fn, 0) > 0) {
-                    /* This is a socket activated socket, therefore do not consider
-                    * it stale. */
-                    return 0;
-                }
-            }
-        }
-    }
-#endif
-
-    if ((r = pa_unix_socket_is_stale(fn)) < 0)
-        return errno != ENOENT ? -1 : 0;
-
-    if (!r)
-        return 0;
-
-    /* Yes, here is a race condition. But who cares? */
-    if (unlink(fn) < 0)
-        return -1;
-
-    return 0;
-}
-
-#else /* HAVE_SYS_UN_H */
-
-int pa_unix_socket_is_stale(const char *fn) {
-    return -1;
-}
-
-int pa_unix_socket_remove_stale(const char *fn) {
-    return -1;
-}
-
-#endif /* HAVE_SYS_UN_H */
-
 bool pa_socket_address_is_local(const struct sockaddr *sa) {
     pa_assert(sa);
 
diff --git a/src/pulsecore/socket-util.h b/src/pulsecore/socket-util.h
index f12076936..83c730bd9 100644
--- a/src/pulsecore/socket-util.h
+++ b/src/pulsecore/socket-util.h
@@ -35,9 +35,6 @@ void pa_make_udp_socket_low_delay(int fd);
 int pa_socket_set_sndbuf(int fd, size_t l);
 int pa_socket_set_rcvbuf(int fd, size_t l);
 
-int pa_unix_socket_is_stale(const char *fn);
-int pa_unix_socket_remove_stale(const char *fn);
-
 bool pa_socket_address_is_local(const struct sockaddr *sa);
 bool pa_socket_is_local(int fd);
 

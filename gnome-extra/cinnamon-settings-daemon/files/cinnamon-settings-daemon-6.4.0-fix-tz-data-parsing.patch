From eec27984940dfb11904b02228357f430b585c41f Mon Sep 17 00:00:00 2001
From: Michael Webster <miketwebster@gmail.com>
Date: Wed, 13 Aug 2025 14:24:38 -0400
Subject: [PATCH] generate-tz-header.py: Fix position coordinate parsing.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

We were reading zone.tab incorrectly, constructing a decimal
value directly from the coordinate data. But described in the
companion zone1970.tab file (tzdata package), the format is:
 # 2.  Latitude and longitude of the timezone's principal location
 #     in ISO 6709 sign-degrees-minutes-seconds format,
 #     either ±DDMM±DDDMM or ±DDMMSS±DDDMMSS,
 #     first latitude (+ is north), then longitude (+ is east).

Update our script to parse and convert these coordinates into
decimal values correctly.

Fixes #415.
---
 plugins/color/generate-tz-header.py |  11 +-
 plugins/color/tz-coords.h           | 834 ++++++++++++++--------------
 2 files changed, 421 insertions(+), 424 deletions(-)

diff --git a/plugins/color/generate-tz-header.py b/plugins/color/generate-tz-header.py
index d725727..59954f1 100755
--- a/plugins/color/generate-tz-header.py
+++ b/plugins/color/generate-tz-header.py
@@ -4,7 +4,7 @@
 from argparse import ArgumentParser
 from pathlib import Path
 
-COORDS_RE = re.compile(r"([+-])([0-9]+)([+-])([0-9]+)")
+COORDS_RE = re.compile(r"([+-]{1}[0-9]{2})([0-9]{2})([0-9]*)([+-]{1}[0-9]{3})([0-9]{2})([0-9]*)")
 
 d = {}
 
@@ -21,13 +21,10 @@
             continue
 
         coords, tz = line.split('\t')[1:3]
-        lat_sign, lat_val, long_sign, long_val = COORDS_RE.search(coords).groups()
+        lat_deg, lat_min, lat_sec, long_deg, long_min, long_sec = COORDS_RE.search(coords).groups()
 
-        lat_str = lat_sign + lat_val[0:2] + "." + lat_val[2:]
-        long_str = long_sign + long_val[0:3] + "." + long_val[3:]
-
-        lat = float(lat_str)
-        long = float(long_str)
+        lat = float(lat_deg + str((int(lat_min) / 60.0) + ((int(lat_sec) if lat_sec else 0) / 3600.0))[1:])
+        long = float(long_deg + str((int(long_min) / 60.0) + ((int(long_sec) if long_sec else 0) / 3600.0))[1:])
 
         d[tz] = [lat, long]
 

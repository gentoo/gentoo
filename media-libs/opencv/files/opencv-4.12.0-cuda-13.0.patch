From 5a1306ddccb709cc5c8c4bb503125ab49a6a95b3 Mon Sep 17 00:00:00 2001
From: Paul Zander <negril.nx+gentoo@gmail.com>
Date: Wed, 6 Aug 2025 14:27:28 +0200
Subject: [PATCH] cuda 13.0 support

Signed-off-by: Paul Zander <negril.nx+gentoo@gmail.com>

diff --git a/modules/core/src/cuda_info.cpp b/modules/core/src/cuda_info.cpp
index 2558ec8..35b76e7 100644
--- a/modules/core/src/cuda_info.cpp
+++ b/modules/core/src/cuda_info.cpp
@@ -424,7 +424,9 @@ int cv::cuda::DeviceInfo::clockRate() const
 #ifndef HAVE_CUDA
     throw_no_cuda();
 #else
-    return deviceProps().get(device_id_)->clockRate;
+    int i32value;
+    cudaSafeCall( cudaDeviceGetAttribute(&i32value, cudaDevAttrClockRate, device_id_) );
+    return i32value;
 #endif
 }
 
@@ -487,7 +489,9 @@ bool cv::cuda::DeviceInfo::kernelExecTimeoutEnabled() const
 #ifndef HAVE_CUDA
     throw_no_cuda();
 #else
-    return deviceProps().get(device_id_)->kernelExecTimeoutEnabled != 0;
+    int i32value;
+    cudaSafeCall( cudaDeviceGetAttribute(&i32value, cudaDevAttrKernelExecTimeout, device_id_) );
+    return (i32value != 0);
 #endif
 }
 
@@ -522,7 +526,9 @@ DeviceInfo::ComputeMode cv::cuda::DeviceInfo::computeMode() const
         ComputeModeExclusiveProcess
     };
 
-    return tbl[deviceProps().get(device_id_)->computeMode];
+    int i32value;
+    cudaSafeCall( cudaDeviceGetAttribute(&i32value, cudaDevAttrComputeMode, device_id_) );
+    return tbl[i32value];
 #endif
 }
 
@@ -554,7 +560,10 @@ int cv::cuda::DeviceInfo::maxTexture1DLinear() const
 #ifndef HAVE_CUDA
     throw_no_cuda();
 #else
-    return deviceProps().get(device_id_)->maxTexture1DLinear;
+    std::size_t i32value;
+    cudaChannelFormatDesc format;
+    cudaSafeCall( cudaDeviceGetTexture1DLinearMaxWidth(&i32value, &format, device_id_) );
+    return i32value;
 #endif
 }
 
@@ -793,7 +802,9 @@ int cv::cuda::DeviceInfo::memoryClockRate() const
 #ifndef HAVE_CUDA
     throw_no_cuda();
 #else
-    return deviceProps().get(device_id_)->memoryClockRate;
+    int i32value;
+    cudaSafeCall( cudaDeviceGetAttribute(&i32value, cudaDevAttrClockRate, device_id_) );
+    return i32value;
 #endif
 }
 
@@ -924,6 +935,15 @@ void cv::cuda::printCudaDeviceInfo(int device)
         cudaDeviceProp prop;
         cudaSafeCall( cudaGetDeviceProperties(&prop, dev) );
 
+        int clockRate;
+        cudaSafeCall( cudaDeviceGetAttribute(&clockRate, cudaDevAttrClockRate, dev) );
+
+        int KernelExecTimeout;
+        cudaSafeCall( cudaDeviceGetAttribute(&KernelExecTimeout, cudaDevAttrKernelExecTimeout, dev) );
+
+        int ComputeMode;
+        cudaSafeCall( cudaDeviceGetAttribute(&ComputeMode, cudaDevAttrComputeMode, dev) );
+
         printf("\nDevice %d: \"%s\"\n", dev, prop.name);
         printf("  CUDA Driver Version / Runtime Version          %d.%d / %d.%d\n", driverVersion/1000, driverVersion%100, runtimeVersion/1000, runtimeVersion%100);
         printf("  CUDA Capability Major/Minor version number:    %d.%d\n", prop.major, prop.minor);
@@ -933,7 +953,7 @@ void cv::cuda::printCudaDeviceInfo(int device)
         if (cores > 0)
             printf("  (%2d) Multiprocessors x (%2d) CUDA Cores/MP:     %d CUDA Cores\n", prop.multiProcessorCount, cores, cores * prop.multiProcessorCount);
 
-        printf("  GPU Clock Speed:                               %.2f GHz\n", prop.clockRate * 1e-6f);
+        printf("  GPU Clock Speed:                               %.2f GHz\n", clockRate * 1e-6f);
 
         printf("  Max Texture Dimension Size (x,y,z)             1D=(%d), 2D=(%d,%d), 3D=(%d,%d,%d)\n",
             prop.maxTexture1D, prop.maxTexture2D[0], prop.maxTexture2D[1],
@@ -952,8 +972,8 @@ void cv::cuda::printCudaDeviceInfo(int device)
         printf("  Maximum memory pitch:                          %u bytes\n", (int)prop.memPitch);
         printf("  Texture alignment:                             %u bytes\n", (int)prop.textureAlignment);
 
-        printf("  Concurrent copy and execution:                 %s with %d copy engine(s)\n", (prop.deviceOverlap ? "Yes" : "No"), prop.asyncEngineCount);
-        printf("  Run time limit on kernels:                     %s\n", prop.kernelExecTimeoutEnabled ? "Yes" : "No");
+        printf("  Concurrent copy and execution:                 %s with %d copy engine(s)\n", (prop.asyncEngineCount ? "Yes" : "No"), prop.asyncEngineCount);
+        printf("  Run time limit on kernels:                     %s\n", (KernelExecTimeout != 0) ? "Yes" : "No");
         printf("  Integrated GPU sharing Host Memory:            %s\n", prop.integrated ? "Yes" : "No");
         printf("  Support host page-locked memory mapping:       %s\n", prop.canMapHostMemory ? "Yes" : "No");
 
@@ -964,7 +984,7 @@ void cv::cuda::printCudaDeviceInfo(int device)
         printf("  Device supports Unified Addressing (UVA):      %s\n", prop.unifiedAddressing ? "Yes" : "No");
         printf("  Device PCI Bus ID / PCI location ID:           %d / %d\n", prop.pciBusID, prop.pciDeviceID );
         printf("  Compute Mode:\n");
-        printf("      %s \n", computeMode[prop.computeMode]);
+        printf("      %s \n", computeMode[ComputeMode]);
     }
 
     printf("\n");
-- 
2.50.1


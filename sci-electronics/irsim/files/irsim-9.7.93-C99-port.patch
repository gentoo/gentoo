--- a/base/sched.c
+++ b/base/sched.c
@@ -49,9 +49,7 @@ private	evhdr  ev_array[TSIZE];	    /* u
  * events are found;
  */
 
-public Ulong pending_events( delta, list, end_of_list )
-  Ulong   delta;
-  evptr  *list, *end_of_list;
+public Ulong pending_events( Ulong delta, evptr *list, evptr *end_of_list )
   {
     evhdr           *hdr;
     register evptr  ev;
@@ -112,8 +110,7 @@ public Ulong pending_events( delta, list
  * the list of events to be processed at this time, removing it first
  * from the time wheel.
  */
-public evptr get_next_event( stop_time )
-  Ulong  stop_time;
+public evptr get_next_event( Ulong stop_time )
   {
     register evptr  event;
     Ulong i, time, limit;
@@ -206,8 +203,7 @@ public
 /*
  * remove event from all structures it belongs to and return it to free pool
  */
-public void free_event( event )
-  register evptr  event;
+public void free_event( register evptr event )
   {
 	/* unhook from doubly-linked event list */
     event->blink->flink = event->flink;
@@ -236,9 +232,7 @@ public void free_event( event )
  * Add an event to event list, specifying transition delay and new value.
  * 0 delay transitions are converted into unit delay transitions (0.01 ns).
  */
-public void enqueue_event( n, newvalue, delta, rtime )
-  register nptr  n;
-  long           delta, rtime;
+public void enqueue_event( register nptr n, int newvalue, long delta, long rtime )
   {
     register evptr  marker, new;
     Ulong   etime;
@@ -309,8 +303,7 @@ public void enqueue_event( n, newvalue,
 
 
 /* same as enqueue_event, but assumes 0 delay and rise/fall time */
-public void enqueue_input( n, newvalue )
-  register nptr  n;
+public void enqueue_input( register nptr n, int newvalue )
   {
     register evptr  marker, new;
     register Ulong  etime;
@@ -361,9 +354,7 @@ public void init_event()
   }
 
 
-public void PuntEvent( node, ev )
-  nptr   node;
-  evptr  ev;
+public void PuntEvent( nptr node, evptr ev )
   {
     if( node->nflags & WATCHED )
 	lprintf( stdout,
@@ -383,9 +374,7 @@ public void PuntEvent( node, ev )
   }
 
 
-public void requeue_events( evlist, thread )
-  evptr  evlist;
-  int    thread;
+public void requeue_events( evptr evlist, int thread )
   {
     register Ulong   etime;
     register evptr  ev, next, target;
@@ -441,9 +430,7 @@ public void requeue_events( evlist, thre
  * and re-enqueue them according to their creation-time (ntime - delay).
  */
 
-public evptr back_sim_time( btime, is_inc )
-  Ulong  btime;
-  int   is_inc;
+public evptr back_sim_time( Ulong btime, int is_inc )
   {
     evptr           tmplist;
     register int    nevents;
@@ -530,10 +517,7 @@ public evptr back_sim_time( btime, is_in
  * of every node.  Return FALSE if this history entry is the sentinel
  * (last_hist), otherwise return TRUE.
  */
-public int EnqueueHist( nd, hist, type )
-  nptr  nd;
-  hptr  hist;
-  int   type;
+public int EnqueueHist( nptr nd, hptr hist, int type )
   {
     register evptr  marker, new;
     register Ulong   etime;
@@ -608,8 +592,7 @@ public int EnqueueHist( nd, hist, type )
  * Find a scheduled event in the event queue and return a pointer to it.
  */
 
-public evptr FindScheduled(idx)
-   short idx;
+public evptr FindScheduled(short idx)
 {
     register evptr  ev, next;
     register evhdr  *hdr, *endhdr;
@@ -632,8 +615,7 @@ public evptr FindScheduled(idx)
  * Remove a scheduled event from the event queue
  */
 
-public void DequeueScheduled(idx)
-   short idx;
+public void DequeueScheduled(short idx)
 {
     register evptr  ev;
 
@@ -646,8 +628,7 @@ public void DequeueScheduled(idx)
  * that generated it.
  */
 
-public void DequeueEvent( nd )
-  register nptr nd;
+public void DequeueEvent( register nptr nd )
   {
     register evptr  ev;
 
@@ -662,9 +643,7 @@ public void DequeueEvent( nd )
   }
 
 
-public void DelayEvent( ev, delay )
-  evptr  ev;
-  long   delay;
+public void DelayEvent( evptr ev, long delay )
   {
     register evptr  marker, new;
     register nptr   nd;
@@ -716,9 +695,7 @@ public void DelayEvent( ev, delay )
   }
 
 
-public evptr EnqueueOther( type, time )
-  int   type;
-  Ulong  time;
+public evptr EnqueueOther( int type, Ulong time )
   {
     register evptr  marker, new;
     Ulong   etime;
@@ -751,8 +728,7 @@ public evptr EnqueueOther( type, time )
 /*
  * Remove any events that may be left from the incremental simulation.
  */
-public void rm_inc_events( all )
-  int  all;
+public void rm_inc_events( int all )
   {
     register int    nevents;
     register evptr  ev, next;
--- a/analyzer/base.c
+++ b/analyzer/base.c
@@ -12,6 +12,7 @@
  *     *********************************************************************
  */
 
+#include <ctype.h>
 #include "ana.h"
 #include "ana_glob.h"
 #include "graphics.h"
--- a/usersubckt/subckt.c
+++ b/usersubckt/subckt.c
@@ -1,6 +1,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#include <string.h>
 
 #ifdef TCL_IRSIM
 #include <tk.h>
--- a/base/eval.c
+++ b/base/eval.c
@@ -12,6 +12,7 @@
  *     ********************************************************************* 
  */
 
+#include <stdlib.h>
 #include <stdio.h>
 
 #ifdef TCL_IRSIM
@@ -87,8 +88,7 @@ public void ReInit()
 /*
  * Print decay event.
  */
-private void pr_decay( e )
-  evptr  e;
+private void pr_decay( evptr e )
   {
     nptr  n = e->enode;
 
@@ -100,9 +100,7 @@ private void pr_decay( e )
 /*
  * Print watched node event.
  */
-private void pr_watched( e, n )
-  evptr  e;
-  nptr   n;
+private void pr_watched( evptr e, nptr n )
   {
     int   tmp;
 
@@ -136,9 +134,7 @@ private void pr_watched( e, n )
 /*
  * Print capwatched node event.
  */
-private void pr_capwatched( e, n )
-  evptr  e;
-  nptr   n;
+private void pr_capwatched( evptr e, nptr n )
   {
     if ( caplogfile == NULL ) 
 	return;
@@ -164,8 +160,7 @@ private void pr_capwatched( e, n )
 /*
  * Tally cap * trans for giving stepwise power display
  */
-private void acc_step_power( n )
-  nptr   n;
+private void acc_step_power( nptr n )
   {
      if ( not (n->nflags & INPUT) )
 	 step_cap_x_trans += n->ncap;
@@ -362,8 +357,7 @@ private void MarkNodes( evlist )
   }
 
 
-private long EvalNodes( evlist )
-  evptr  evlist;
+private long EvalNodes( evptr evlist )
   {
     register tptr   t;
     register lptr   l;
@@ -439,9 +433,7 @@ private long EvalNodes( evlist )
  * Change the state of the nodes in the given input list to their new value,
  * setting their INPUT flag and enqueueing the event.
  */
-private void SetInputs( listp, val )
-  register iptr  *listp;
-  register int   val;
+private void SetInputs( iptr *listp, int val )
   {
     register nptr  n;
     iptr           ip, last;
@@ -507,8 +499,7 @@ private void EvalNOinputs()
   }
 
 
-public int step( stop_time )
-  Ulong  stop_time;
+public int step( Ulong stop_time )
   {
     evptr  evlist;
     long   brk_flag;
@@ -594,8 +585,7 @@ public
 	switch_state[ BASETYPE( (TRANS)->ttype ) ][ (TRANS)->gate->npot ] )
 
 
-public int ComputeTransState( t )
-  register tptr  t;
+public int ComputeTransState( tptr t )
   {
     register nptr  n;
     register tptr  l;
--- a/analyzer/defaults.c
+++ b/analyzer/defaults.c
@@ -68,8 +68,7 @@ private	Assoc assoc[] =
 
 private	char  *irsim = "irsim";
 
-public char *GetXDefault( key )
-  int  key;
+public char *GetXDefault( int key )
   {
     char         *val;
 
@@ -78,9 +77,7 @@ public char *GetXDefault( key )
   }
 
 
-public int IsDefault( key, val )
-  int   key;
-  char  *val;
+public int IsDefault( int key, char *val )
   {
     if( assoc[ key ].defl == val )
 	return( TRUE );
@@ -88,7 +85,7 @@ public int IsDefault( key, val )
   }
 
 
-public char *ProgDefault( key )
+public char *ProgDefault( int key )
   {
     return( assoc[ key ].defl );
   }
--- a/irsim/genspktbl.c
+++ b/irsim/genspktbl.c
@@ -49,9 +49,7 @@ double	delaytab[ SPIKETBLSIZE + 1 ][ SPI
 FILE	*F;
 
 
-main( argc, argv )
-  int   argc;
-  char  *argv[];
+int main( int argc, char *argv[] )
   {
     char  *fname;
     char  *size = "SPIKETBLSIZE";
@@ -95,9 +93,7 @@ main( argc, argv )
   }
 
 
-void PrintTable( tab, fmt )
-  double  tab[ SPIKETBLSIZE+1 ][ SPIKETBLSIZE+1 ];
-  char    *fmt;
+void PrintTable( double tab[ SPIKETBLSIZE+1 ][ SPIKETBLSIZE+1 ], char *fmt )
   {
     register  int  alpha, beta;
 
@@ -204,8 +200,7 @@ void rk4_error( which, alpha, beta, h )
  *         i) h == .001; .04 < alpha < .96; .04 < beta < .96
  * 	  ii) h == .01;  .1  < alpha < .9;  .1  < beta < .9
  */
-double nldl_rk4( alpha, beta, h )
-  double alpha, beta, h;
+double nldl_rk4( double alpha, double beta, double h )
   {   
     double        k11, k12, k21, k22, k31, k32, k41, k42;
     double        v1old, v1new, v2old, v2new;
@@ -247,8 +242,7 @@ double nldl_rk4( alpha, beta, h )
  * This routine computes the parameter vector for Runge-Kutta method.
  * Customized for 2-transistors-2-capacitors network driven by Gnd.
  */
-void nldl_vector( alpha, beta, h, v1, v2, k1, k2 )
-  double alpha, beta, h, v1, v2, *k1, *k2;
+void nldl_vector( double alpha, double beta, double h, double v1, double v2, double *k1, double *k2 )
   {   
     double  u1, u2;
     
@@ -276,8 +270,7 @@ void nldl_vector( alpha, beta, h, v1, v2
  *         i) h == .001; .04 < alpha < .96; .04 < beta < .96
  * 	  ii) h == .01;  .1  < alpha < .9;  .1  < beta < .9
  */
-double nldh_rk4( alpha, beta, h )
-  double alpha, beta, h;
+double nldh_rk4( double alpha, double beta, double h )
   {   
     double        k11, k12, k21, k22, k31, k32, k41, k42;
     double        v1old, v1new, v2old, v2new;
@@ -319,8 +312,7 @@ double nldh_rk4( alpha, beta, h )
  * This routine computes the parameter vector for Runge-Kutta method.
  * Customized for 2-transistors-2-capacitors network driven by Vdd.
  */
-void nldh_vector( alpha, beta, h, v1, v2, k1, k2 )
-  double alpha, beta, h, v1, v2, *k1, *k2;
+void nldh_vector( double alpha, double beta, double h, double v1, double v2, double *k1, double *k2 )
   {   
     double  u1, u2;
     
@@ -336,8 +328,7 @@ void nldh_vector( alpha, beta, h, v1, v2
  * Compute spike fluctuation and delay using an rc linear model.
  * Use equations for driven by Gnd case
  */
-void linear_spike( alpha, beta, delay, peak )
-  double  alpha, beta, *delay, *peak;
+void linear_spike( double alpha, double beta, double *delay, double *peak )
   {
     double  N, b, a, x, tmp;
 
--- a/base/network.c
+++ b/base/network.c
@@ -14,6 +14,7 @@
 
 #include <stdio.h>
 #include <stdlib.h>
+#include <string.h>
 
 #include "defs.h"
 #include "net.h"
--- a/analyzer/graphics.c
+++ b/analyzer/graphics.c
@@ -51,10 +51,7 @@ private	char   bots_bits[3][2] = { 0x7,
 #define	SAME_COLOR( A, B )	\
     ( (A).red == (B).red and (A).green == (B).green and (A).blue == (B).blue )
 
-private int GetColor( key, colors, ndefined )
-  int     key;
-  XColor  colors[];
-  int     ndefined;
+private int GetColor( int key, XColor colors[], int ndefined )
   {
     char      *s;
     XColor    *color;
@@ -222,10 +219,7 @@ private void InitBitmaps()
   }
 
 
-private Cursor MakeCursor( fg, bg, curs, mask, w, h, x, y )
-  XColor  *fg, *bg;
-  char    *curs, *mask;
-  int     w, h;
+private Cursor MakeCursor( XColor *fg, XColor *bg, char *curs, char *mask, int w, int h, int x, int y )
   {
     Pixmap  pcurs, pmask;
     Cursor  cu;
@@ -269,8 +263,7 @@ private void InitCursors()
   }
 
 
-public void InitGraphics(font)
-  Font  font;
+public void InitGraphics(Font font)
   {
     XGCValues      gcv;
     unsigned long  mask;
--- a/base/globals.h
+++ b/base/globals.h
@@ -307,8 +307,8 @@ extern evptr back_sim_time( /*  btime, i
 extern int EnqueueHist( /*  nd, hist, type */ );
 extern void DequeueEvent( /*  nd */ );
 extern void DelayEvent( /*  ev, delay */ );
-extern evptr FindScheduled( /* idx */ );
-extern void DequeueScheduled( /* idx */ );
+extern evptr FindScheduled( short /* idx */ );
+extern void DequeueScheduled( short /* idx */ );
 extern evptr EnqueueOther( /*  type, time */ );
 extern void rm_inc_events( /*  all */ );
 
--- a/analyzer/thread.c
+++ b/analyzer/thread.c
@@ -21,6 +21,11 @@ extern Display *display;
 extern Window  window;
 extern Func FGetEvent;
 
+extern void HandleButton( XButtonEvent *ev );
+extern void HandleKey( XKeyEvent *ev );
+extern void WindowExposed( XExposeEvent *event );
+extern void WindowResize( XConfigureEvent *ev );
+
 pthread_t xloop_thread = 0;
 Func EventHandlerPtr = NULL;
 
--- a/analyzer/event.c
+++ b/analyzer/event.c
@@ -61,8 +61,7 @@ private	int     x_server = 0;
 private	int     x_helper = 0;		/* process id of helper process */
 public	Func    FGetEvent = NULL;	/* used also in thread.c */
 
-public void WindowResize( ev )
-  XConfigureEvent  *ev;
+public void WindowResize( XConfigureEvent *ev )
   {
     int  ret;
 
@@ -75,8 +74,7 @@ public void WindowResize( ev )
   }
 
 
-public void WindowExposed( event )
-  XExposeEvent  *event;
+public void WindowExposed( XExposeEvent *event )
   {
     BBox  box;
 
@@ -88,8 +86,7 @@ public void WindowExposed( event )
   }
 
 
-public void HandleButton( ev )
-  XButtonEvent  *ev;
+public void HandleButton( XButtonEvent *ev )
   {
     if( WITHINY( ev->y, scrollBox ) )
 	DoScrollBar( ev );
@@ -123,8 +120,7 @@ public void HandleButton( ev )
   }
 
 
-public void HandleKey( ev )
-  XKeyEvent  *ev;
+public void HandleKey( XKeyEvent *ev )
   {
     char  buff[ 40 ];
     int   nChars, i;
@@ -312,8 +308,7 @@ private void DisabledEventHandler()
 
 #ifdef NEED_HELPER
 
-private int StartHelper( fd )
-  int  fd;
+private int StartHelper( int fd )
   {
     extern char  *cad_bin, *getenv();
     static char  helper_name[] = "anXhelper";
@@ -355,8 +350,7 @@ private int StartHelper( fd )
 
 #endif /* NEED_HELPER */
 
-public int InitHandler( fd )
-  int fd;
+public int InitHandler( int fd )
   {
     int   flags;
     char  *senv;
--- a/base/rsim.c
+++ b/base/rsim.c
@@ -95,6 +95,10 @@ public  float   step_cap_x_trans = 0;	/*
 private int undefseq( /* p, list, lmax */ );
 private int clockit( /* n */ );
 
+extern void EnableInput( /* */ );
+extern void DisableInput( /* */ );
+extern void alias( int targc, char *targv[] );
+
 #ifdef TCL_IRSIM
 extern Tcl_Interp *irsiminterp;
 extern int check_interrupt();
--- a/base/sim.c
+++ b/base/sim.c
@@ -22,7 +22,7 @@
  *  2. static power calculations not performed (only useful for nmos anyhow).
  */
 
-
+#include <math.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -88,9 +88,7 @@ private	char    bad_argc_msg[] = "Wrong
   }							\
 
 
-private void PrArgs( argc, argv )
-  int   argc;
-  char  *argv[];
+private void PrArgs( int argc, char *argv[] )
   {
     while( argc-- != 0 )
       (void) fprintf( stderr, "%s ", *argv++ );
@@ -98,7 +96,7 @@ private void PrArgs( argc, argv )
   }
 
 
-private void CheckErrs( n )
+private void CheckErrs( int n )
   {
     nerrs += n;
     if( nerrs > MAX_ERRS )
@@ -181,9 +179,7 @@ private nptr connect_txtors()
 /*
  * node area and perimeter info (N sim command).
  */
-private void node_info( targc, targv )
-  int   targc;
-  char  *targv[];
+private void node_info( int targc, char *targv[] )
   {
     register nptr  n;
 
@@ -202,9 +198,7 @@ private void node_info( targc, targv )
 /*
  * new format node area and perimeter info (M sim command).
  */
-private void nnode_info( targc, targv )
-  int   targc;
-  char  *targv[];
+private void nnode_info( int targc, char *targv[] )
   {
     register nptr  n;
 
@@ -233,9 +227,7 @@ private	int    AP_error = FALSE;
 /* lambda^2 and lambda, respectively.			*/
 /*------------------------------------------------------*/
 
-private int parseAttr(str, a, p)
-char *str;
-int *a, *p;
+private int parseAttr(char *str, int *a, int *p)
 {
    int l;
    char *s;
@@ -260,8 +252,7 @@ int *a, *p;
 /* Default (unspecified) values are treated as ohms.		*/
 /*--------------------------------------------------------------*/
 
-private float rconvert( resstring )
-  char *resstring;
+private float rconvert( char *resstring )
 {
    /* Convert string to floating-point, and stop at the	*/
    /* first non-numeric character.			*/
@@ -298,8 +289,7 @@ private float rconvert( resstring )
 /* converted to centimicrons using the LAMBDACM factor.		*/
 /*--------------------------------------------------------------*/
 
-private float lconvert( lstring )
-  char *lstring;
+private float lconvert( char *lstring )
 {
    /* Convert string to floating-point, and stop at the	*/
    /* first non-numeric character.			*/
@@ -331,10 +321,7 @@ private float lconvert( lstring )
  * new transistor.  Implant specifies type.
  * AreaPos specifies the argument number that contains the area (if any).
  */
-private void newtrans( implant, targc, targv )
-  int   implant;
-  int   targc;
-  char  *targv[];
+private void newtrans( int implant, int targc, char *targv[] )
   {
     nptr           gate, src, drn;
     long           x, y;
@@ -469,9 +456,7 @@ printf("LAMBDA=%f CDA=%f CDP=%f asrc=%d
 /*
  * accept a bunch of aliases for a node (= sim command).
  */
-public void alias( targc, targv )
-  int   targc;
-  char  *targv[];
+public void alias( int targc, char *targv[] )
   {
     register nptr  n, m;
     register int   i;
@@ -510,9 +495,7 @@ public void alias( targc, targv )
 /*
  * node threshold voltages (t sim command).
  */
-private void nthresh( targc, targv )
-  int   targc;
-  char  *targv[];
+private void nthresh( int targc, char *targv[] )
   {
     register nptr  n;
 
@@ -528,9 +511,7 @@ private void nthresh( targc, targv )
 /*
  * User delay for a node (D sim command).
  */
-private void ndelay( targc, targv )
-  int   targc;
-  char  *targv[];
+private void ndelay( int targc, char *targv[] )
   {
     register nptr  n;
 
@@ -543,8 +524,7 @@ private void ndelay( targc, targv )
     n->tphl = ns2d( atof( targv[3] ) );
   }
 
-private float cconvert( capstring )
-  char *capstring;
+private float cconvert( char *capstring )
 {
    /* Convert string to floating-point, and stop at the	*/
    /* first non-numeric character.			*/
@@ -577,9 +557,7 @@ private float cconvert( capstring )
 /*
  * add capacitance to a node (c sim command).
  */
-private void ncap( targc, targv )
-  int   targc;
-  char  *targv[];
+private void ncap( int targc, char *targv[] )
   {
     register nptr n, m;
     float         cap;
@@ -610,9 +588,7 @@ private void ncap( targc, targv )
 /*
  * parse input line into tokens, filling up carg and setting targc
  */
-private int parse_line( line, carg )
-  register char  *line;
-  register char  **carg;
+private int parse_line( register char *line, register char **carg )
   {
     register char  ch;
     register int   targc;
@@ -637,9 +613,7 @@ private int parse_line( line, carg )
 private	int    R_error = FALSE;
 private	int    A_error = FALSE;
 
-private int input_sim (simfile, has_param_file)
-  char  *simfile;
-  int   has_param_file;
+private int input_sim (char *simfile, int has_param_file)
 {
     FILE  *fin;
     char  line[LSIZE];
@@ -699,7 +673,7 @@ private int input_sim (simfile, has_para
 		offset = ftell(fin);
 		olineno = lineno;
 		(void) fclose(fin);
-		(void) input_sim(targv[1]);
+		(void) input_sim(targv[1], 0);
 		if ((fin = fopen(simfile, "r")) == NULL)
 		{
 		    rsimerror(simfname, lineno, "can't re-open sim file '%s'\n",
@@ -872,10 +846,7 @@ private void init_counts()
 }
 
 
-public int rd_network( simfile, prefix, has_param_file )
-  char  *simfile;
-  char  *prefix;
-  int   has_param_file;
+public int rd_network( char *simfile, char *prefix, int has_param_file )
   {
     static int      firstcall = 1;
 
--- a/analyzer/window.c
+++ b/analyzer/window.c
@@ -18,6 +18,7 @@
  */
 #include <stdio.h>
 #include <string.h>   /* for strlen() */
+#include <stdlib.h>
 #include "ana.h"
 #include <X11/Xutil.h>
 #include "graphics.h"
@@ -45,12 +46,13 @@ public	int         bannerLen;
 private	void    DrawSignal(), DrawVector(), DrawCursor();
 private	void    MoveCursorToPos(), EraseCursor();
 
+extern int xloop_create();
+
 /*
  * Convert a time to its corresponding x position.
  */
 
-public Coord TimeToX(t)
-    TimeType t;
+public Coord TimeToX(TimeType t)
 {
     Coord xval;
 
@@ -68,8 +70,7 @@ public Coord TimeToX(t)
  * Return (MAX_TIME) if the point lies outside the traces window.
  */
 
-public TimeType XToTime(x)
-    Coord  x;
+public TimeType XToTime(Coord x)
 {
     float  tmp;
     int denom;
@@ -140,9 +141,7 @@ public int SetFont()
  * Initialize the windows and various other metrics.
  */
 
-public int InitDisplay( fname, display_unit )
-  char  *fname;
-  char  *display_unit;
+public int InitDisplay( char *fname, char *display_unit )
   {
 #ifdef HAVE_PTHREADS
     XInitThreads();
@@ -180,11 +179,7 @@ public int InitDisplay( fname, display_u
   }
 
 
-public int InitWindow( firstTime, state, x, y, w, h, ix, iy )
-  int    firstTime;
-  int    state;
-  Coord  x, y, w, h;
-  Coord  ix, iy;
+public int InitWindow( int firstTime, int state, Coord x, Coord y, Coord w, Coord h, Coord ix, Coord iy )
   {
     int                   spec, u_spec;
     static int            b;
@@ -283,9 +278,7 @@ public
  * shown on the screen.  Default width is DEF_STEPS (simulation) steps.
  */
 
-public void InitTimes(firstT, stepsize, lastT, reInit)
-  TimeType  firstT, stepsize, lastT;
-  int reInit;
+public void InitTimes(TimeType firstT, TimeType stepsize, TimeType lastT, int reInit)
 {
     tims.first = firstT;
     tims.last = lastT;
@@ -324,8 +317,7 @@ public void InitTimes(firstT, stepsize,
 /*
  * Redraw any region that overlaps the redraw-box.
  */
-public void RedrawWindow( box )
-  BBox  box;
+public void RedrawWindow( BBox box )
   {
 
 #ifndef TCL_IRSIM
@@ -392,8 +384,7 @@ public void RedrawBanner()
   }
 
 
-public void WindowCrossed( selected )
-  int  selected;
+public void WindowCrossed( int selected )
   {
     GC  color;
 
@@ -463,8 +454,7 @@ public void RedrawTimes()
   }
 
 
-public void UpdateTimes( start, end )
-  TimeType  start, end;
+public void UpdateTimes( TimeType start, TimeType end )
   {
     static TimeType  ostart, oend;
     static int       slen, elen;
@@ -503,8 +493,7 @@ public void UpdateTimes( start, end )
 /*
  * Redraw signal names.
  */
-public void RedrawNames( rb )
-  BBox  rb;
+public void RedrawNames( BBox rb )
   {
     Coord  x, y;
     Trptr  t;
@@ -540,8 +529,7 @@ public void RedrawNames( rb )
  * This will redraw the missing parts of the traces.  Used to selectivelly
  * repaint traces or during Exposure events.
  */
-public void RedrawTraces( box )
-  BBox  *box;
+public void RedrawTraces( BBox *box )
   {
     TimeType        t1, t2, tc;
     BBox            bg;
@@ -603,8 +591,7 @@ public void RedrawTraces( box )
  * Update the cache (begining of window and cursor) for traces that just
  * became visible ( or were just added ).
  */
-public void UpdateTraceCache( first_trace )
-  int  first_trace;
+public void UpdateTraceCache( int first_trace )
   {
     register Trptr     t;
     register hptr      h,p;
@@ -710,8 +697,7 @@ public void FlushTraceCache()
 /*
  * Draw the traces horizontally from time1 to time2.
  */
-public void DrawTraces( t1, t2 )
-  TimeType  t1, t2;
+public void DrawTraces( TimeType t1, TimeType t2 )
   {
     TimeType         endT;
     register Trptr   t;
@@ -779,9 +765,7 @@ public void DrawTraces( t1, t2 )
 /*
  * Draw a 1 bit trace.
  */
-private void DrawSignal( t, t1, t2 )
-  Trptr              t;
-  register TimeType  t1, t2;
+private void DrawSignal( Trptr t, register TimeType t1, register TimeType t2 )
   {
     register hptr  h;
     register int   val, change;
@@ -847,10 +831,7 @@ public	hptr    tmpHBuff[ 400 ];
 /*
  * Draw bus trace.
  */
-private void DrawVector( t, t1, t2, clr_bg )
-  register Trptr     t;
-  register TimeType  t1, t2;
-  int                clr_bg;
+private void DrawVector( register Trptr t, register TimeType t1, register TimeType t2, int clr_bg )
   {
     hptr      *start, *changes;
     TimeType  firstChange;
@@ -997,8 +978,7 @@ private void DrawVector( t, t1, t2, clr_
 
 
 
-private void UpdateTraces( start, end )
-  TimeType  start, end;
+private void UpdateTraces( TimeType start, TimeType end )
   {
     if( not (windowState.iconified or windowState.tooSmall) )
       {
@@ -1009,8 +989,7 @@ private void UpdateTraces( start, end )
   }
 
 
-private void ScrollTraces( endT )
-  TimeType  endT;
+private void ScrollTraces( TimeType endT )
   {
     tims.start = endT - tims.steps / 2;
     tims.end = tims.start + tims.steps;
@@ -1023,8 +1002,7 @@ private void ScrollTraces( endT )
  * window, simply draw the missing parts.  Otherwise scroll the traces,
  * centered around endT.
  */
-public void UpdateWindow( endT )
-  TimeType  endT;
+public void UpdateWindow( TimeType endT )
   {
     TimeType  lastT;
 
@@ -1108,9 +1086,7 @@ private void  DrawCursor()
   }
 
 
-public void SetCursor( t, time )
-  Trptr t;
-  TimeType time;
+public void SetCursor( Trptr t, TimeType time )
 {
     register hptr  h, p;
     register int   n;
@@ -1150,8 +1126,7 @@ public void SetCursor( t, time )
     PRINTF( "%s, input=%s", val, inp );
 }
 
-void DoCursor( ev )
-  XButtonEvent  *ev;
+void DoCursor( XButtonEvent *ev )
   {
     Trptr     t;
     TimeType  time;
@@ -1249,8 +1224,7 @@ public void MoveCursorToTime(TimeType ti
     DrawCursVal( cursorBox );
   }
 
-private void MoveCursorToPos( x )
-  Coord  x;
+private void MoveCursorToPos( Coord x )
 {
     register TimeType  time;
 
@@ -1264,8 +1238,7 @@ private	char  *StrMap[] = { "0", "X", ""
 /*
  * Display signal values under cursor.
  */
-public void DrawCursVal( rb )
-  BBox  rb;
+public void DrawCursVal( BBox rb )
   {
     Coord        y;
     Trptr        t;
@@ -1301,8 +1274,7 @@ public void DrawCursVal( rb )
   }
 
 
-public void ExpandCursVal( t )
-  Trptr  t;
+public void ExpandCursVal( Trptr t )
   {
     char          *val;
     int           nbits;
--- a/irsim/irsim.c
+++ b/irsim/irsim.c
@@ -24,8 +24,11 @@
 #include "../usersubckt/subckt.h"
 #endif
 
+extern void InitCmdPath();
+extern public void init_commands();
+extern int finput( char *name);
+
 /* VARARGS1 */
-public void Usage( msg, s1 )
-  char  *msg, *s1;
+public void Usage( char *msg, char *s1 )
   {
     (void) fprintf( stderr, msg, s1 );
@@ -39,8 +43,7 @@ public void Usage( msg, s1 )
 
 /* Main routine for irsim */
 
-public main( argc, argv )
-   char *argv[];
+public int main( int argc, char *argv[] )
   {
     int  i, arg1, has_param_file;
 
--- a/irsim/gentbl.c
+++ b/irsim/gentbl.c
@@ -35,7 +35,7 @@ FILE  *out;
 
 
 /* name of interval */
-char *pinterval( high, low )
+char *pinterval( int high, int low )
   {
     static char  temp[100];
 
@@ -48,8 +48,7 @@ char *pinterval( high, low )
 
 
 /* return strength of value */
-int strength( i )
-  register int  i;
+int strength( register int i )
   {
     if( (i -= NVALUES) < 0 )
 	i = -i;
@@ -60,14 +59,14 @@ int strength( i )
 #define max( A, B )			( ((A) > (B)) ? (A) : (B) )
 
 /* find the enclosing interval */
-char *span( ihigh, ilow, jhigh, jlow )
+char *span( int ihigh,int ilow,int jhigh, int jlow )
   {
     return( pinterval( min( ihigh, jhigh ), max( ilow, jlow ) ) );
   }
 
 
 /* merge two intervals using least-upper bound operation */
-char *merge( ihigh, ilow, jhigh, jlow )
+char *merge( int ihigh, int ilow, int jhigh, int jlow )
   {
     register int  ahigh, alow;
 
@@ -94,7 +93,7 @@ char *merge( ihigh, ilow, jhigh, jlow )
 
 
 /* convert interval to use weak values */
-char *weak( i, j )
+char *weak( int i, int j )
   {
     if( i == 0 )
 	i = 1;
@@ -108,7 +107,7 @@ char *weak( i, j )
   }
 
 
-main()
+int main(void)
   {
     register int  i, j, k, ii, jj, interval2;
 

https://github.com/tome2/tome2/pull/77
Compatibility with the packaged version of dev-cpp/jsoncons

--- a/src/squelch/automatizer.cc
+++ b/src/squelch/automatizer.cc
@@ -22,9 +22,7 @@ static std::vector< std::shared_ptr < Rule > > parse_rules(jsoncons::json const
 		return rules;
 	}
 
-	auto rules_array = rules_json.array_value();
-
-	for (auto const &rule_value : rules_array)
+	for (auto const &rule_value : rules_json.array_range())
 	{
 		auto rule = Rule::parse_rule(rule_value);
 		if (rule)
--- a/src/squelch/condition.cc
+++ b/src/squelch/condition.cc
@@ -376,7 +376,7 @@ std::shared_ptr<Condition> GroupingCondition::next_child(Condition *current)
 
 std::vector< std::shared_ptr<Condition> > GroupingCondition::parse_conditions(jsoncons::json const &j)
 {
-	auto conditions_j = j.get_with_default<jsoncons::json>("conditions", jsoncons::null_type());
+	auto conditions_j = j.get_value_or<jsoncons::json>("conditions", jsoncons::null_type());
 
 	if (conditions_j.is_null())
 	{
@@ -390,7 +390,7 @@ std::vector< std::shared_ptr<Condition> > GroupingCondition::parse_conditions(js
 	else
 	{
 		std::vector< std::shared_ptr<Condition> > subconditions;
-		for (auto const &subcondition_j: conditions_j.array_value())
+		for (auto const &subcondition_j: conditions_j.array_range())
 		{
 			std::shared_ptr<Condition> subcondition =
 				parse_condition(subcondition_j);
@@ -931,7 +931,7 @@ void SingleSubconditionCondition::to_json(jsoncons::json &j) const
 
 std::shared_ptr<Condition> SingleSubconditionCondition::parse_single_subcondition(jsoncons::json const &in_json)
 {
-	auto condition_j = in_json.get_with_default<jsoncons::json>("condition", jsoncons::null_type());
+	auto condition_j = in_json.get_value_or<jsoncons::json>("condition", jsoncons::null_type());
 
 	if (condition_j.is_null())
 	{
--- a/src/squelch/jsoncons_helpers.hpp
+++ b/src/squelch/jsoncons_helpers.hpp
@@ -9,7 +9,7 @@ namespace squelch {
 template <class T>
 boost::optional<T> get_optional(jsoncons::json const &json, std::string const &key)
 {
-	if (!json.has_key(key))
+	if (!json.contains(key))
 	{
 		return boost::none;
 	}
--- a/src/squelch/rule.cc
+++ b/src/squelch/rule.cc
@@ -171,14 +171,14 @@ std::shared_ptr<Rule> Rule::parse_rule(jsoncons::json const &rule_json)
 
 	// Parse condition
 	std::shared_ptr<Condition> condition =
-		Condition::parse_condition(rule_json.get_with_default<jsoncons::json>("condition", jsoncons::null_type()));
+		Condition::parse_condition(rule_json.get_value_or<jsoncons::json>("condition", jsoncons::null_type()));
 
 	// Parse rule
 	switch (action)
 	{
 	case action_type::AUTO_INSCRIBE:
 	{
-		auto rule_inscription_j = rule_json.get_with_default<jsoncons::json>("inscription", jsoncons::null_type());
+		auto rule_inscription_j = rule_json.get_value_or<jsoncons::json>("inscription", jsoncons::null_type());
 
 		if (rule_inscription_j.is_null())
 		{
--- a/src/squeltch.cc
+++ b/src/squeltch.cc
@@ -218,8 +219,8 @@ static void automatizer_save_rules()
 	}
 
 	// Write JSON to output
-	jsoncons::serialization_options serialization_options;
-	serialization_options.indent(2);
+	jsoncons::json_options serialization_options;
+	serialization_options.indent_size(2);
 	of << jsoncons::pretty_print(rules_document, serialization_options);
 	if (of.fail())
 	{
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -55,10 +55,12 @@ ENDIF()
 #
 # fmt
 #
 ADD_DEFINITIONS(-DFMT_HEADER_ONLY)
+find_package(jsoncons REQUIRED)
+SET(LIBS ${LIBS} jsoncons::jsoncons)
 
 # Add standard math library
 SET(LIBS ${LIBS} m)
 
 #
 # BOOST

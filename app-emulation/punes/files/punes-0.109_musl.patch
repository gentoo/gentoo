https://bugs.gentoo.org/830471
https://github.com/punesemu/puNES/commit/634e6a2874fbc0497621e597c71004a11ab39e98

From 634e6a2874fbc0497621e597c71004a11ab39e98 Mon Sep 17 00:00:00 2001
From: fhorse <punes.development@gmail.com>
Date: Mon, 28 Mar 2022 00:20:35 +0200
Subject: [PATCH] Updated sha1.c and sha1.h.

This should fix the compilation error with libc musl
https://bugs.gentoo.org/show_bug.cgi?id=830471.
---
 src/core/sha1.c | 711 ++++++++++++++++++++++++++----------------------
 src/core/sha1.h | 153 +++++++----
 2 files changed, 489 insertions(+), 375 deletions(-)

diff --git a/src/core/sha1.c b/src/core/sha1.c
index 474602cae..2856c4cc3 100644
--- a/src/core/sha1.c
+++ b/src/core/sha1.c
@@ -1,24 +1,7 @@
-/*
- *  Copyright (C) 2010-2022 Fabio Cavallo (aka FHorse)
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
 /*
  *  FIPS-180-1 compliant SHA-1 implementation
  *
- *  Copyright (C) 2003-2006  Christophe Devine
+ *  Copyright (C) 2006-2007  Christophe Devine
  *
  *  This library is free software; you can redistribute it and/or
  *  modify it under the terms of the GNU Lesser General Public
@@ -40,114 +23,119 @@
  *  http://www.itl.nist.gov/fipspubs/fip180-1.htm
  */
 
-#ifndef _CRT_SECURE_NO_DEPRECATE
-#define _CRT_SECURE_NO_DEPRECATE 1
-#endif
+// FHorse mod
+#define XYSSL_SHA1_C
+// FHorse mod end
+
+#if defined(XYSSL_SHA1_C)
+
+#include "sha1.h"
 
 #include <string.h>
 #include <stdio.h>
-#include "sha1.h"
-#include "common.h"
 
 /*
  * 32-bit integer manipulation macros (big endian)
  */
-#ifndef GET_UINT32_BE
-#define GET_UINT32_BE(n,b,i)                    \
-{                                               \
-	(n) = ( (ulong) (b)[(i)    ] << 24 )    \
-	    | ( (ulong) (b)[(i) + 1] << 16 )    \
-	    | ( (ulong) (b)[(i) + 2] <<  8 )    \
-	    | ( (ulong) (b)[(i) + 3]       );   \
+#ifndef GET_ULONG_BE
+#define GET_ULONG_BE(n,b,i)                             \
+{                                                       \
+    (n) = ( (unsigned long) (b)[(i)    ] << 24 )        \
+        | ( (unsigned long) (b)[(i) + 1] << 16 )        \
+        | ( (unsigned long) (b)[(i) + 2] <<  8 )        \
+        | ( (unsigned long) (b)[(i) + 3]       );       \
 }
 #endif
-#ifndef PUT_UINT32_BE
-#define PUT_UINT32_BE(n,b,i)                    \
-{                                               \
-	(b)[(i)    ] = (uchar) ( (n) >> 24 );   \
-	(b)[(i) + 1] = (uchar) ( (n) >> 16 );   \
-	(b)[(i) + 2] = (uchar) ( (n) >>  8 );   \
-	(b)[(i) + 3] = (uchar) ( (n)       );   \
+
+#ifndef PUT_ULONG_BE
+#define PUT_ULONG_BE(n,b,i)                             \
+{                                                       \
+    (b)[(i)    ] = (unsigned char) ( (n) >> 24 );       \
+    (b)[(i) + 1] = (unsigned char) ( (n) >> 16 );       \
+    (b)[(i) + 2] = (unsigned char) ( (n) >>  8 );       \
+    (b)[(i) + 3] = (unsigned char) ( (n)       );       \
 }
 #endif
 
 /*
- * Core SHA-1 functions
+ * SHA-1 context setup
  */
-void sha1_starts(sha1_context *ctx) {
-	ctx->total[0] = 0;
-	ctx->total[1] = 0;
-
-	ctx->state[0] = 0x67452301;
-	ctx->state[1] = 0xEFCDAB89;
-	ctx->state[2] = 0x98BADCFE;
-	ctx->state[3] = 0x10325476;
-	ctx->state[4] = 0xC3D2E1F0;
+void sha1_starts( sha1_context *ctx )
+{
+    ctx->total[0] = 0;
+    ctx->total[1] = 0;
+
+    ctx->state[0] = 0x67452301;
+    ctx->state[1] = 0xEFCDAB89;
+    ctx->state[2] = 0x98BADCFE;
+    ctx->state[3] = 0x10325476;
+    ctx->state[4] = 0xC3D2E1F0;
 }
 
-void sha1_process(sha1_context *ctx, uchar data[64]) {
-	ulong temp, W[16], A, B, C, D, E;
-
-	GET_UINT32_BE( W[0], data, 0);
-	GET_UINT32_BE( W[1], data, 4);
-	GET_UINT32_BE( W[2], data, 8);
-	GET_UINT32_BE( W[3], data, 12);
-	GET_UINT32_BE( W[4], data, 16);
-	GET_UINT32_BE( W[5], data, 20);
-	GET_UINT32_BE( W[6], data, 24);
-	GET_UINT32_BE( W[7], data, 28);
-	GET_UINT32_BE( W[8], data, 32);
-	GET_UINT32_BE( W[9], data, 36);
-	GET_UINT32_BE( W[10], data, 40);
-	GET_UINT32_BE( W[11], data, 44);
-	GET_UINT32_BE( W[12], data, 48);
-	GET_UINT32_BE( W[13], data, 52);
-	GET_UINT32_BE( W[14], data, 56);
-	GET_UINT32_BE( W[15], data, 60);
+static void sha1_process( sha1_context *ctx, unsigned char data[64] )
+{
+    unsigned long temp, W[16], A, B, C, D, E;
+
+    GET_ULONG_BE( W[ 0], data,  0 );
+    GET_ULONG_BE( W[ 1], data,  4 );
+    GET_ULONG_BE( W[ 2], data,  8 );
+    GET_ULONG_BE( W[ 3], data, 12 );
+    GET_ULONG_BE( W[ 4], data, 16 );
+    GET_ULONG_BE( W[ 5], data, 20 );
+    GET_ULONG_BE( W[ 6], data, 24 );
+    GET_ULONG_BE( W[ 7], data, 28 );
+    GET_ULONG_BE( W[ 8], data, 32 );
+    GET_ULONG_BE( W[ 9], data, 36 );
+    GET_ULONG_BE( W[10], data, 40 );
+    GET_ULONG_BE( W[11], data, 44 );
+    GET_ULONG_BE( W[12], data, 48 );
+    GET_ULONG_BE( W[13], data, 52 );
+    GET_ULONG_BE( W[14], data, 56 );
+    GET_ULONG_BE( W[15], data, 60 );
 
 #define S(x,n) ((x << n) | ((x & 0xFFFFFFFF) >> (32 - n)))
 
 #define R(t)                                            \
-		(                                                       \
-				temp = W[(t -  3) & 0x0F] ^ W[(t - 8) & 0x0F] ^     \
-				W[(t - 14) & 0x0F] ^ W[ t      & 0x0F],      \
-				( W[t & 0x0F] = S(temp,1) )                         \
-		)
+(                                                       \
+    temp = W[(t -  3) & 0x0F] ^ W[(t - 8) & 0x0F] ^     \
+           W[(t - 14) & 0x0F] ^ W[ t      & 0x0F],      \
+    ( W[t & 0x0F] = S(temp,1) )                         \
+)
 
 #define P(a,b,c,d,e,x)                                  \
-		{                                                       \
-	e += S(a,5) + F(b,c,d) + K + x; b = S(b,30);        \
-		}
+{                                                       \
+    e += S(a,5) + F(b,c,d) + K + x; b = S(b,30);        \
+}
 
-	A = ctx->state[0];
-	B = ctx->state[1];
-	C = ctx->state[2];
-	D = ctx->state[3];
-	E = ctx->state[4];
+    A = ctx->state[0];
+    B = ctx->state[1];
+    C = ctx->state[2];
+    D = ctx->state[3];
+    E = ctx->state[4];
 
 #define F(x,y,z) (z ^ (x & (y ^ z)))
 #define K 0x5A827999
 
-	P( A, B, C, D, E, W[0]);
-	P( E, A, B, C, D, W[1]);
-	P( D, E, A, B, C, W[2]);
-	P( C, D, E, A, B, W[3]);
-	P( B, C, D, E, A, W[4]);
-	P( A, B, C, D, E, W[5]);
-	P( E, A, B, C, D, W[6]);
-	P( D, E, A, B, C, W[7]);
-	P( C, D, E, A, B, W[8]);
-	P( B, C, D, E, A, W[9]);
-	P( A, B, C, D, E, W[10]);
-	P( E, A, B, C, D, W[11]);
-	P( D, E, A, B, C, W[12]);
-	P( C, D, E, A, B, W[13]);
-	P( B, C, D, E, A, W[14]);
-	P( A, B, C, D, E, W[15]);
-	P( E, A, B, C, D, R(16));
-	P( D, E, A, B, C, R(17));
-	P( C, D, E, A, B, R(18));
-	P( B, C, D, E, A, R(19));
+    P( A, B, C, D, E, W[0]  );
+    P( E, A, B, C, D, W[1]  );
+    P( D, E, A, B, C, W[2]  );
+    P( C, D, E, A, B, W[3]  );
+    P( B, C, D, E, A, W[4]  );
+    P( A, B, C, D, E, W[5]  );
+    P( E, A, B, C, D, W[6]  );
+    P( D, E, A, B, C, W[7]  );
+    P( C, D, E, A, B, W[8]  );
+    P( B, C, D, E, A, W[9]  );
+    P( A, B, C, D, E, W[10] );
+    P( E, A, B, C, D, W[11] );
+    P( D, E, A, B, C, W[12] );
+    P( C, D, E, A, B, W[13] );
+    P( B, C, D, E, A, W[14] );
+    P( A, B, C, D, E, W[15] );
+    P( E, A, B, C, D, R(16) );
+    P( D, E, A, B, C, R(17) );
+    P( C, D, E, A, B, R(18) );
+    P( B, C, D, E, A, R(19) );
 
 #undef K
 #undef F
@@ -155,26 +143,26 @@ void sha1_process(sha1_context *ctx, uchar data[64]) {
 #define F(x,y,z) (x ^ y ^ z)
 #define K 0x6ED9EBA1
 
-	P( A, B, C, D, E, R(20));
-	P( E, A, B, C, D, R(21));
-	P( D, E, A, B, C, R(22));
-	P( C, D, E, A, B, R(23));
-	P( B, C, D, E, A, R(24));
-	P( A, B, C, D, E, R(25));
-	P( E, A, B, C, D, R(26));
-	P( D, E, A, B, C, R(27));
-	P( C, D, E, A, B, R(28));
-	P( B, C, D, E, A, R(29));
-	P( A, B, C, D, E, R(30));
-	P( E, A, B, C, D, R(31));
-	P( D, E, A, B, C, R(32));
-	P( C, D, E, A, B, R(33));
-	P( B, C, D, E, A, R(34));
-	P( A, B, C, D, E, R(35));
-	P( E, A, B, C, D, R(36));
-	P( D, E, A, B, C, R(37));
-	P( C, D, E, A, B, R(38));
-	P( B, C, D, E, A, R(39));
+    P( A, B, C, D, E, R(20) );
+    P( E, A, B, C, D, R(21) );
+    P( D, E, A, B, C, R(22) );
+    P( C, D, E, A, B, R(23) );
+    P( B, C, D, E, A, R(24) );
+    P( A, B, C, D, E, R(25) );
+    P( E, A, B, C, D, R(26) );
+    P( D, E, A, B, C, R(27) );
+    P( C, D, E, A, B, R(28) );
+    P( B, C, D, E, A, R(29) );
+    P( A, B, C, D, E, R(30) );
+    P( E, A, B, C, D, R(31) );
+    P( D, E, A, B, C, R(32) );
+    P( C, D, E, A, B, R(33) );
+    P( B, C, D, E, A, R(34) );
+    P( A, B, C, D, E, R(35) );
+    P( E, A, B, C, D, R(36) );
+    P( D, E, A, B, C, R(37) );
+    P( C, D, E, A, B, R(38) );
+    P( B, C, D, E, A, R(39) );
 
 #undef K
 #undef F
@@ -182,26 +170,26 @@ void sha1_process(sha1_context *ctx, uchar data[64]) {
 #define F(x,y,z) ((x & y) | (z & (x | y)))
 #define K 0x8F1BBCDC
 
-	P( A, B, C, D, E, R(40));
-	P( E, A, B, C, D, R(41));
-	P( D, E, A, B, C, R(42));
-	P( C, D, E, A, B, R(43));
-	P( B, C, D, E, A, R(44));
-	P( A, B, C, D, E, R(45));
-	P( E, A, B, C, D, R(46));
-	P( D, E, A, B, C, R(47));
-	P( C, D, E, A, B, R(48));
-	P( B, C, D, E, A, R(49));
-	P( A, B, C, D, E, R(50));
-	P( E, A, B, C, D, R(51));
-	P( D, E, A, B, C, R(52));
-	P( C, D, E, A, B, R(53));
-	P( B, C, D, E, A, R(54));
-	P( A, B, C, D, E, R(55));
-	P( E, A, B, C, D, R(56));
-	P( D, E, A, B, C, R(57));
-	P( C, D, E, A, B, R(58));
-	P( B, C, D, E, A, R(59));
+    P( A, B, C, D, E, R(40) );
+    P( E, A, B, C, D, R(41) );
+    P( D, E, A, B, C, R(42) );
+    P( C, D, E, A, B, R(43) );
+    P( B, C, D, E, A, R(44) );
+    P( A, B, C, D, E, R(45) );
+    P( E, A, B, C, D, R(46) );
+    P( D, E, A, B, C, R(47) );
+    P( C, D, E, A, B, R(48) );
+    P( B, C, D, E, A, R(49) );
+    P( A, B, C, D, E, R(50) );
+    P( E, A, B, C, D, R(51) );
+    P( D, E, A, B, C, R(52) );
+    P( C, D, E, A, B, R(53) );
+    P( B, C, D, E, A, R(54) );
+    P( A, B, C, D, E, R(55) );
+    P( E, A, B, C, D, R(56) );
+    P( D, E, A, B, C, R(57) );
+    P( C, D, E, A, B, R(58) );
+    P( B, C, D, E, A, R(59) );
 
 #undef K
 #undef F
@@ -209,260 +197,327 @@ void sha1_process(sha1_context *ctx, uchar data[64]) {
 #define F(x,y,z) (x ^ y ^ z)
 #define K 0xCA62C1D6
 
-	P( A, B, C, D, E, R(60));
-	P( E, A, B, C, D, R(61));
-	P( D, E, A, B, C, R(62));
-	P( C, D, E, A, B, R(63));
-	P( B, C, D, E, A, R(64));
-	P( A, B, C, D, E, R(65));
-	P( E, A, B, C, D, R(66));
-	P( D, E, A, B, C, R(67));
-	P( C, D, E, A, B, R(68));
-	P( B, C, D, E, A, R(69));
-	P( A, B, C, D, E, R(70));
-	P( E, A, B, C, D, R(71));
-	P( D, E, A, B, C, R(72));
-	P( C, D, E, A, B, R(73));
-	P( B, C, D, E, A, R(74));
-	P( A, B, C, D, E, R(75));
-	P( E, A, B, C, D, R(76));
-	P( D, E, A, B, C, R(77));
-	P( C, D, E, A, B, R(78));
-	P( B, C, D, E, A, R(79));
+    P( A, B, C, D, E, R(60) );
+    P( E, A, B, C, D, R(61) );
+    P( D, E, A, B, C, R(62) );
+    P( C, D, E, A, B, R(63) );
+    P( B, C, D, E, A, R(64) );
+    P( A, B, C, D, E, R(65) );
+    P( E, A, B, C, D, R(66) );
+    P( D, E, A, B, C, R(67) );
+    P( C, D, E, A, B, R(68) );
+    P( B, C, D, E, A, R(69) );
+    P( A, B, C, D, E, R(70) );
+    P( E, A, B, C, D, R(71) );
+    P( D, E, A, B, C, R(72) );
+    P( C, D, E, A, B, R(73) );
+    P( B, C, D, E, A, R(74) );
+    P( A, B, C, D, E, R(75) );
+    P( E, A, B, C, D, R(76) );
+    P( D, E, A, B, C, R(77) );
+    P( C, D, E, A, B, R(78) );
+    P( B, C, D, E, A, R(79) );
 
 #undef K
 #undef F
 
-	ctx->state[0] += A;
-	ctx->state[1] += B;
-	ctx->state[2] += C;
-	ctx->state[3] += D;
-	ctx->state[4] += E;
+    ctx->state[0] += A;
+    ctx->state[1] += B;
+    ctx->state[2] += C;
+    ctx->state[3] += D;
+    ctx->state[4] += E;
 }
 
-void sha1_update(sha1_context *ctx, uchar *input, uint length) {
-	ulong left, fill;
+/*
+ * SHA-1 process buffer
+ */
+void sha1_update( sha1_context *ctx, unsigned char *input, int ilen )
+{
+    int fill;
+    unsigned long left;
+
+    if( ilen <= 0 )
+        return;
+
+    left = ctx->total[0] & 0x3F;
+    fill = 64 - left;
+
+    ctx->total[0] += ilen;
+    ctx->total[0] &= 0xFFFFFFFF;
+
+    if( ctx->total[0] < (unsigned long) ilen )
+        ctx->total[1]++;
+
+    if( left && ilen >= fill )
+    {
+        memcpy( (void *) (ctx->buffer + left),
+                (void *) input, fill );
+        sha1_process( ctx, ctx->buffer );
+        input += fill;
+        ilen  -= fill;
+        left = 0;
+    }
+
+    while( ilen >= 64 )
+    {
+        sha1_process( ctx, input );
+        input += 64;
+        ilen  -= 64;
+    }
+
+    if( ilen > 0 )
+    {
+        memcpy( (void *) (ctx->buffer + left),
+                (void *) input, ilen );
+    }
+}
 
-	if (!length)
-		return;
+static const unsigned char sha1_padding[64] =
+{
+ 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+};
 
-	left = ctx->total[0] & 0x3F;
-	fill = 64 - left;
+/*
+ * SHA-1 final digest
+ */
+void sha1_finish( sha1_context *ctx, unsigned char output[20] )
+{
+    unsigned long last, padn;
+    unsigned long high, low;
+    unsigned char msglen[8];
 
-	ctx->total[0] += length;
-	ctx->total[0] &= 0xFFFFFFFF;
+    high = ( ctx->total[0] >> 29 )
+         | ( ctx->total[1] <<  3 );
+    low  = ( ctx->total[0] <<  3 );
 
-	if (ctx->total[0] < length)
-		ctx->total[1]++;
+    PUT_ULONG_BE( high, msglen, 0 );
+    PUT_ULONG_BE( low,  msglen, 4 );
 
-	if (left && length >= fill) {
-		memcpy((void *) (ctx->buffer + left), (void *) input, fill);
-		sha1_process(ctx, ctx->buffer);
-		length -= fill;
-		input += fill;
-		left = 0;
-	}
+    last = ctx->total[0] & 0x3F;
+    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
 
-	while (length >= 64) {
-		sha1_process(ctx, input);
-		length -= 64;
-		input += 64;
-	}
+    sha1_update( ctx, (unsigned char *) sha1_padding, padn );
+    sha1_update( ctx, msglen, 8 );
 
-	if (length) {
-		memcpy((void *) (ctx->buffer + left), (void *) input, length);
-	}
+    PUT_ULONG_BE( ctx->state[0], output,  0 );
+    PUT_ULONG_BE( ctx->state[1], output,  4 );
+    PUT_ULONG_BE( ctx->state[2], output,  8 );
+    PUT_ULONG_BE( ctx->state[3], output, 12 );
+    PUT_ULONG_BE( ctx->state[4], output, 16 );
 }
 
-static uchar sha1_padding[64] = { 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-		0, 0 };
-
-void sha1_finish(sha1_context *ctx, uchar digest[20]) {
-	ulong last, padn;
-	ulong high, low;
-	uchar msglen[8];
-
-	high = (ctx->total[0] >> 29) | (ctx->total[1] << 3);
-	low = (ctx->total[0] << 3);
-
-	PUT_UINT32_BE( high, msglen, 0);
-	PUT_UINT32_BE( low, msglen, 4);
-
-	last = ctx->total[0] & 0x3F;
-	padn = (last < 56) ? (56 - last) : (120 - last);
+/*
+ * output = SHA-1( input buffer )
+ */
+void sha1( unsigned char *input, int ilen, unsigned char output[20] )
+{
+    sha1_context ctx;
 
-	sha1_update(ctx, sha1_padding, padn);
-	sha1_update(ctx, msglen, 8);
+    sha1_starts( &ctx );
+    sha1_update( &ctx, input, ilen );
+    sha1_finish( &ctx, output );
 
-	PUT_UINT32_BE( ctx->state[0], digest, 0);
-	PUT_UINT32_BE( ctx->state[1], digest, 4);
-	PUT_UINT32_BE( ctx->state[2], digest, 8);
-	PUT_UINT32_BE( ctx->state[3], digest, 12);
-	PUT_UINT32_BE( ctx->state[4], digest, 16);
+    memset( &ctx, 0, sizeof( sha1_context ) );
 }
 
 /*
- * Output SHA-1(file contents), returns 0 if successful.
+ * output = SHA-1( file contents )
  */
-int sha1_file(char *filename, uchar digest[20], char *string) {
-	FILE *f;
-	size_t n;
-	sha1_context ctx;
-	uchar buf[1024];
-	uchar i;
+int sha1_file( char *path, unsigned char output[20] )
+{
+    FILE *f;
+    size_t n;
+    sha1_context ctx;
+    unsigned char buf[1024];
 
-	if ((f = fopen(filename, "rb")) == NULL) {
-		return (1);
-	}
+    if( ( f = fopen( path, "rb" ) ) == NULL )
+        return( 1 );
 
-	sha1_starts(&ctx);
+    sha1_starts( &ctx );
 
-	while ((n = fread(buf, 1, sizeof(buf), f)) > 0) {
-		sha1_update(&ctx, buf, (uint) n);
-	}
+    while( ( n = fread( buf, 1, sizeof( buf ), f ) ) > 0 )
+        sha1_update( &ctx, buf, (int) n );
 
-	sha1_finish(&ctx, digest);
+    sha1_finish( &ctx, output );
 
-	fclose(f);
+    memset( &ctx, 0, sizeof( sha1_context ) );
 
-	memset(string, 0x00, 41);
+    if( ferror( f ) != 0 )
+    {
+        fclose( f );
+        return( 2 );
+    }
 
-	for (i = 0; i < 20; i++) {
-		char hex2char[3];
-		sprintf(hex2char, "%02x", digest[i]);
-		strcat(string, hex2char);
-	}
-	return (0);
+    fclose( f );
+    return( 0 );
 }
 
 /*
- * Output SHA-1(buf)
+ * SHA-1 HMAC context setup
  */
-void sha1_csum(uchar *buf, uint buflen, uchar digest[20], char *string, int typecase) {
-	sha1_context ctx;
-	uchar i;
+void sha1_hmac_starts( sha1_context *ctx, unsigned char *key, int keylen )
+{
+    int i;
+    unsigned char sum[20];
 
-	sha1_starts(&ctx);
-	sha1_update(&ctx, buf, buflen);
-	sha1_finish(&ctx, digest);
+    if( keylen > 64 )
+    {
+        sha1( key, keylen, sum );
+        keylen = 20;
+        key = sum;
+    }
 
-	memset(string, 0x00, 41);
+    memset( ctx->ipad, 0x36, 64 );
+    memset( ctx->opad, 0x5C, 64 );
 
-	for (i = 0; i < 20; i++) {
-		char hex2char[3];
-		if (typecase == UPPER) {
-			sprintf(hex2char, "%02X", digest[i]);
-		} else {
-			sprintf(hex2char, "%02x", digest[i]);
-		}
-		strcat(string, hex2char);
-	}
+    for( i = 0; i < keylen; i++ )
+    {
+        ctx->ipad[i] = (unsigned char)( ctx->ipad[i] ^ key[i] );
+        ctx->opad[i] = (unsigned char)( ctx->opad[i] ^ key[i] );
+    }
+
+    sha1_starts( ctx );
+    sha1_update( ctx, ctx->ipad, 64 );
+
+    memset( sum, 0, sizeof( sum ) );
 }
 
 /*
- * Output HMAC-SHA-1(key,buf)
+ * SHA-1 HMAC process buffer
  */
-void sha1_hmac(uchar *key, uint keylen, uchar *buf, uint buflen, uchar digest[20]) {
-	uint i;
-	sha1_context ctx;
-	uchar k_ipad[64];
-	uchar k_opad[64];
-	uchar tmpbuf[20];
+void sha1_hmac_update( sha1_context *ctx, unsigned char *input, int ilen )
+{
+    sha1_update( ctx, input, ilen );
+}
 
-	memset(k_ipad, 0x36, 64);
-	memset(k_opad, 0x5C, 64);
+/*
+ * SHA-1 HMAC final digest
+ */
+void sha1_hmac_finish( sha1_context *ctx, unsigned char output[20] )
+{
+    unsigned char tmpbuf[20];
 
-	for (i = 0; i < keylen; i++) {
-		if (i >= 64)
-			break;
+    sha1_finish( ctx, tmpbuf );
+    sha1_starts( ctx );
+    sha1_update( ctx, ctx->opad, 64 );
+    sha1_update( ctx, tmpbuf, 20 );
+    sha1_finish( ctx, output );
 
-		k_ipad[i] ^= key[i];
-		k_opad[i] ^= key[i];
-	}
+    memset( tmpbuf, 0, sizeof( tmpbuf ) );
+}
 
-	sha1_starts(&ctx);
-	sha1_update(&ctx, k_ipad, 64);
-	sha1_update(&ctx, buf, buflen);
-	sha1_finish(&ctx, tmpbuf);
+/*
+ * output = HMAC-SHA-1( hmac key, input buffer )
+ */
+void sha1_hmac( unsigned char *key, int keylen, unsigned char *input, int ilen,
+                unsigned char output[20] )
+{
+    sha1_context ctx;
 
-	sha1_starts(&ctx);
-	sha1_update(&ctx, k_opad, 64);
-	sha1_update(&ctx, tmpbuf, 20);
-	sha1_finish(&ctx, digest);
+    sha1_hmac_starts( &ctx, key, keylen );
+    sha1_hmac_update( &ctx, input, ilen );
+    sha1_hmac_finish( &ctx, output );
 
-	memset(k_ipad, 0, 64);
-	memset(k_opad, 0, 64);
-	memset(tmpbuf, 0, 20);
-	memset(&ctx, 0, sizeof(sha1_context));
+    memset( &ctx, 0, sizeof( sha1_context ) );
 }
 
-#ifdef SELF_TEST
+#if defined(XYSSL_SELF_TEST)
+
 /*
  * FIPS-180-1 test vectors
  */
-static char *sha1_test_str[3] =
+static const char sha1_test_str[3][57] = 
 {
-	"abc",
-	"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
-	NULL
+    { "abc" },
+    { "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq" },
+    { "" }
 };
 
-static uchar sha1_test_sum[3][20] =
+static const unsigned char sha1_test_sum[3][20] =
 {
-	{	0xA9, 0x99, 0x3E, 0x36, 0x47, 0x06, 0x81, 0x6A, 0xBA, 0x3E,
-		0x25, 0x71, 0x78, 0x50, 0xC2, 0x6C, 0x9C, 0xD0, 0xD8, 0x9D},
-	{	0x84, 0x98, 0x3E, 0x44, 0x1C, 0x3B, 0xD2, 0x6E, 0xBA, 0xAE,
-		0x4A, 0xA1, 0xF9, 0x51, 0x29, 0xE5, 0xE5, 0x46, 0x70, 0xF1},
-	{	0x34, 0xAA, 0x97, 0x3C, 0xD4, 0xC4, 0xDA, 0xA4, 0xF6, 0x1E,
-		0xEB, 0x2B, 0xDB, 0xAD, 0x27, 0x31, 0x65, 0x34, 0x01, 0x6F}
+    { 0xA9, 0x99, 0x3E, 0x36, 0x47, 0x06, 0x81, 0x6A, 0xBA, 0x3E,
+      0x25, 0x71, 0x78, 0x50, 0xC2, 0x6C, 0x9C, 0xD0, 0xD8, 0x9D },
+    { 0x84, 0x98, 0x3E, 0x44, 0x1C, 0x3B, 0xD2, 0x6E, 0xBA, 0xAE,
+      0x4A, 0xA1, 0xF9, 0x51, 0x29, 0xE5, 0xE5, 0x46, 0x70, 0xF1 },
+    { 0x34, 0xAA, 0x97, 0x3C, 0xD4, 0xC4, 0xDA, 0xA4, 0xF6, 0x1E,
+      0xEB, 0x2B, 0xDB, 0xAD, 0x27, 0x31, 0x65, 0x34, 0x01, 0x6F }
 };
 
 /*
  * Checkup routine
  */
-int sha1_self_test( void )
+int sha1_self_test( int verbose )
 {
-	int i, j;
-	uchar buf[1000];
-	uchar sha1sum[20];
-	sha1_context ctx;
+    int i, j;
+    unsigned char buf[1000];
+    unsigned char sha1sum[20];
+    sha1_context ctx;
+
+    for( i = 0; i < 3; i++ )
+    {
+        if( verbose != 0 )
+            printf( "  SHA-1 test #%d: ", i + 1 );
+
+        sha1_starts( &ctx );
+
+        if( i < 2 )
+            sha1_update( &ctx, (unsigned char *) sha1_test_str[i],
+                         strlen( sha1_test_str[i] ) );
+        else
+        {
+            memset( buf, 'a', 1000 );
+            for( j = 0; j < 1000; j++ )
+                sha1_update( &ctx, buf, 1000 );
+        }
+
+        sha1_finish( &ctx, sha1sum );
+
+        if( memcmp( sha1sum, sha1_test_sum[i], 20 ) != 0 )
+        {
+            if( verbose != 0 )
+                printf( "failed\n" );
+
+            return( 1 );
+        }
+
+        if( verbose != 0 )
+            printf( "passed\n" );
+    }
+
+    if( verbose != 0 )
+        printf( "\n" );
+
+    return( 0 );
+}
 
-	for( i = 0; i < 3; i++ )
-	{
-		printf( "  SHA-1 test #%d: ", i + 1 );
+#endif
 
-		sha1_starts( &ctx );
+#endif
 
-		if( i < 2 )
-		sha1_update( &ctx, (uchar *) sha1_test_str[i],
-				strlen( sha1_test_str[i] ) );
-		else
-		{
-			memset( buf, 'a', 1000 );
-			for( j = 0; j < 1000; j++ )
-			sha1_update( &ctx, (uchar *) buf, 1000 );
-		}
+// FHorse mod
+#include "common.h"
 
-		sha1_finish( &ctx, sha1sum );
+void sha1_csum(unsigned char *buf, int buflen, unsigned char digest[20], char *string, int typecase) {
+	sha1_context ctx;
+	unsigned char i;
 
-		if( memcmp( sha1sum, sha1_test_sum[i], 20 ) != 0 )
-		{
-			printf( "failed\n" );
-			return( 1 );
-		}
+	sha1_starts(&ctx);
+	sha1_update(&ctx, buf, buflen);
+	sha1_finish(&ctx, digest);
 
-		printf( "passed\n" );
-	}
+	memset(string, 0x00, 41);
 
-	printf( "\n" );
-	return( 0 );
-}
-#else
-int sha1_self_test(void) {
-	printf("SHA-1 self-test not available\n\n");
-	return (1);
+	for (i = 0; i < 20; i++) {
+		char hex2char[3];
+		if (typecase == UPPER) {
+			sprintf(hex2char, "%02X", digest[i]);
+		} else {
+			sprintf(hex2char, "%02x", digest[i]);
+		}
+		strcat(string, hex2char);
+	}
 }
-
-#endif
+// FHorse mod end
diff --git a/src/core/sha1.h b/src/core/sha1.h
index d810339f6..f6c161bf8 100644
--- a/src/core/sha1.h
+++ b/src/core/sha1.h
@@ -1,64 +1,123 @@
-/*
- *  Copyright (C) 2010-2022 Fabio Cavallo (aka FHorse)
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+/**
+ * \file sha1.h
  */
+#ifndef XYSSL_SHA1_H
+#define XYSSL_SHA1_H
 
-#ifndef SHA1_H_
-#define SHA1_H_
+/**
+ * \brief          SHA-1 context structure
+ */
+typedef struct
+{
+    unsigned long total[2];     /*!< number of bytes processed  */
+    unsigned long state[5];     /*!< intermediate digest state  */
+    unsigned char buffer[64];   /*!< data block being processed */
 
-#include "common.h"
+    unsigned char ipad[64];     /*!< HMAC: inner padding        */
+    unsigned char opad[64];     /*!< HMAC: outer padding        */
+}
+sha1_context;
 
-#ifndef _STD_TYPES
-#define _STD_TYPES
-#define uchar unsigned char
-#define uint  unsigned int
-#define ulong unsigned long int
+#ifdef __cplusplus
+extern "C" {
 #endif
 
-typedef struct {
-	ulong total[2];
-	ulong state[5];
-	uchar buffer[64];
-} sha1_context;
+/**
+ * \brief          SHA-1 context setup
+ *
+ * \param ctx      context to be initialized
+ */
+void sha1_starts( sha1_context *ctx );
 
-/*
- * Core SHA-1 functions
+/**
+ * \brief          SHA-1 process buffer
+ *
+ * \param ctx      SHA-1 context
+ * \param input    buffer holding the  data
+ * \param ilen     length of the input data
  */
-void sha1_starts(sha1_context *ctx);
-void sha1_update(sha1_context *ctx, uchar *input, uint length);
-void sha1_finish(sha1_context *ctx, uchar digest[20]);
+void sha1_update( sha1_context *ctx, unsigned char *input, int ilen );
 
-/*
- * Output SHA-1(file contents), returns 0 if successful.
+/**
+ * \brief          SHA-1 final digest
+ *
+ * \param ctx      SHA-1 context
+ * \param output   SHA-1 checksum result
  */
-int sha1_file(char *filename, uchar digest[20], char *string);
+void sha1_finish( sha1_context *ctx, unsigned char output[20] );
 
-/*
- * Output SHA-1(buf)
+/**
+ * \brief          Output = SHA-1( input buffer )
+ *
+ * \param input    buffer holding the  data
+ * \param ilen     length of the input data
+ * \param output   SHA-1 checksum result
  */
-void sha1_csum(uchar *buf, uint buflen, uchar digest[20], char *string, int typecase);
+void sha1( unsigned char *input, int ilen, unsigned char output[20] );
 
-/*
- * Output HMAC-SHA-1(key,buf)
+/**
+ * \brief          Output = SHA-1( file contents )
+ *
+ * \param path     input file name
+ * \param output   SHA-1 checksum result
+ *
+ * \return         0 if successful, 1 if fopen failed,
+ *                 or 2 if fread failed
  */
-void sha1_hmac(uchar *key, uint keylen, uchar *buf, uint buflen, uchar digest[20]);
+int sha1_file( char *path, unsigned char output[20] );
 
-/*
- * Checkup routine
+/**
+ * \brief          SHA-1 HMAC context setup
+ *
+ * \param ctx      HMAC context to be initialized
+ * \param key      HMAC secret key
+ * \param keylen   length of the HMAC key
  */
-int sha1_self_test(void);
+void sha1_hmac_starts( sha1_context *ctx, unsigned char *key, int keylen );
+
+/**
+ * \brief          SHA-1 HMAC process buffer
+ *
+ * \param ctx      HMAC context
+ * \param input    buffer holding the  data
+ * \param ilen     length of the input data
+ */
+void sha1_hmac_update( sha1_context *ctx, unsigned char *input, int ilen );
+
+/**
+ * \brief          SHA-1 HMAC final digest
+ *
+ * \param ctx      HMAC context
+ * \param output   SHA-1 HMAC checksum result
+ */
+void sha1_hmac_finish( sha1_context *ctx, unsigned char output[20] );
+
+/**
+ * \brief          Output = HMAC-SHA-1( hmac key, input buffer )
+ *
+ * \param key      HMAC secret key
+ * \param keylen   length of the HMAC key
+ * \param input    buffer holding the  data
+ * \param ilen     length of the input data
+ * \param output   HMAC-SHA-1 result
+ */
+void sha1_hmac( unsigned char *key, int keylen,
+                unsigned char *input, int ilen,
+                unsigned char output[20] );
+
+/**
+ * \brief          Checkup routine
+ *
+ * \return         0 if successful, or 1 if the test failed
+ */
+int sha1_self_test( int verbose );
+
+// FHorse mod
+void sha1_csum(unsigned char *buf, int buflen, unsigned char digest[20], char *string, int typecase);
+// FHorse mod end
+
+#ifdef __cplusplus
+}
+#endif
 
-#endif /* SHA1_H_ */
+#endif /* sha1.h */

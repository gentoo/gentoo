# https://github.com/ziglang/zig/pull/24928

From: Justus Klausecker <justus@klausecker.de>

zig reduce: adapt to new Writer API

diff --git a/lib/compiler/reduce.zig b/lib/compiler/reduce.zig
index d9955b9e3383..b20a2fcba318 100644
--- a/lib/compiler/reduce.zig
+++ b/lib/compiler/reduce.zig
@@ -114,10 +114,10 @@ pub fn main() !void {
     interestingness_argv.appendAssumeCapacity(checker_path);
     interestingness_argv.appendSliceAssumeCapacity(argv);
 
-    var rendered = std.array_list.Managed(u8).init(gpa);
+    var rendered: std.Io.Writer.Allocating = .init(gpa);
     defer rendered.deinit();
 
-    var astgen_input = std.array_list.Managed(u8).init(gpa);
+    var astgen_input: std.Io.Writer.Allocating = .init(gpa);
     defer astgen_input.deinit();
 
     var tree = try parse(gpa, root_source_file_path);
@@ -138,10 +138,10 @@ pub fn main() !void {
         }
     }
 
-    var fixups: Ast.Fixups = .{};
+    var fixups: Ast.Render.Fixups = .{};
     defer fixups.deinit(gpa);
 
-    var more_fixups: Ast.Fixups = .{};
+    var more_fixups: Ast.Render.Fixups = .{};
     defer more_fixups.deinit(gpa);
 
     var rng = std.Random.DefaultPrng.init(seed);
@@ -188,15 +188,14 @@ pub fn main() !void {
             try transformationsToFixups(gpa, arena, root_source_file_path, this_set, &fixups);
 
             rendered.clearRetainingCapacity();
-            try tree.renderToArrayList(&rendered, fixups);
+            try tree.render(gpa, &rendered.writer, fixups);
 
             // The transformations we applied may have resulted in unused locals,
             // in which case we would like to add the respective discards.
             {
-                try astgen_input.resize(rendered.items.len);
-                @memcpy(astgen_input.items, rendered.items);
-                try astgen_input.append(0);
-                const source_with_null = astgen_input.items[0 .. astgen_input.items.len - 1 :0];
+                try astgen_input.writer.writeAll(rendered.written());
+                try astgen_input.writer.writeByte(0);
+                const source_with_null = astgen_input.written()[0..(astgen_input.written().len - 1) :0];
                 var astgen_tree = try Ast.parse(gpa, source_with_null, .zig);
                 defer astgen_tree.deinit(gpa);
                 if (astgen_tree.errors.len != 0) {
@@ -228,12 +227,12 @@ pub fn main() !void {
                     }
                     if (more_fixups.count() != 0) {
                         rendered.clearRetainingCapacity();
-                        try astgen_tree.renderToArrayList(&rendered, more_fixups);
+                        try astgen_tree.render(gpa, &rendered.writer, more_fixups);
                     }
                 }
             }
 
-            try std.fs.cwd().writeFile(.{ .sub_path = root_source_file_path, .data = rendered.items });
+            try std.fs.cwd().writeFile(.{ .sub_path = root_source_file_path, .data = rendered.written() });
             // std.debug.print("trying this code:\n{s}\n", .{rendered.items});
 
             const interestingness = try runCheck(arena, interestingness_argv.items);
@@ -273,8 +272,8 @@ pub fn main() !void {
         // Revert the source back to not be transformed.
         fixups.clearRetainingCapacity();
         rendered.clearRetainingCapacity();
-        try tree.renderToArrayList(&rendered, fixups);
-        try std.fs.cwd().writeFile(.{ .sub_path = root_source_file_path, .data = rendered.items });
+        try tree.render(gpa, &rendered.writer, fixups);
+        try std.fs.cwd().writeFile(.{ .sub_path = root_source_file_path, .data = rendered.written() });
 
         return std.process.cleanExit();
     }
@@ -318,7 +317,7 @@ fn transformationsToFixups(
     arena: Allocator,
     root_source_file_path: []const u8,
     transforms: []const Walk.Transformation,
-    fixups: *Ast.Fixups,
+    fixups: *Ast.Render.Fixups,
 ) !void {
     fixups.clearRetainingCapacity();
 
@@ -359,7 +358,7 @@ fn transformationsToFixups(
                 other_file_ast.deinit(gpa);
             }
 
-            var inlined_fixups: Ast.Fixups = .{};
+            var inlined_fixups: Ast.Render.Fixups = .{};
             defer inlined_fixups.deinit(gpa);
             if (std.fs.path.dirname(inline_imported_file.imported_string)) |dirname| {
                 inlined_fixups.rebase_imported_paths = dirname;
@@ -382,16 +381,16 @@ fn transformationsToFixups(
                 }
             }
 
-            var other_source = std.array_list.Managed(u8).init(gpa);
+            var other_source: std.io.Writer.Allocating = .init(gpa);
             defer other_source.deinit();
-            try other_source.appendSlice("struct {\n");
-            try other_file_ast.renderToArrayList(&other_source, inlined_fixups);
-            try other_source.appendSlice("}");
+            try other_source.writer.writeAll("struct {\n");
+            try other_file_ast.render(gpa, &other_source.writer, inlined_fixups);
+            try other_source.writer.writeAll("}");
 
             try fixups.replace_nodes_with_string.put(
                 gpa,
                 inline_imported_file.builtin_call_node,
-                try arena.dupe(u8, other_source.items),
+                try arena.dupe(u8, other_source.written()),
             );
         },
     };
diff --git a/lib/compiler/reduce/Walk.zig b/lib/compiler/reduce/Walk.zig
index 4e41fdf1a2a9..7a448fad2172 100644
--- a/lib/compiler/reduce/Walk.zig
+++ b/lib/compiler/reduce/Walk.zig
@@ -501,6 +501,10 @@ fn walkExpression(w: *Walk, node: Ast.Node.Index) Error!void {
         .@"asm",
         => return walkAsm(w, ast.fullAsm(node).?),
 
+        .asm_legacy => {
+            return walkAsmLegacy(w, ast.legacyAsm(node).?);
+        },
+
         .enum_literal => {
             return walkIdentifier(w, ast.nodeMainToken(node)); // name
         },
@@ -665,7 +669,7 @@ fn walkStructInit(
 
 fn walkCall(w: *Walk, call: Ast.full.Call) Error!void {
     try walkExpression(w, call.ast.fn_expr);
-    try walkParamList(w, call.ast.params);
+    try walkExpressions(w, call.ast.params);
 }
 
 fn walkSlice(
@@ -830,7 +834,7 @@ fn walkWhile(w: *Walk, node_index: Ast.Node.Index, while_node: Ast.full.While) E
 }
 
 fn walkFor(w: *Walk, for_node: Ast.full.For) Error!void {
-    try walkParamList(w, for_node.ast.inputs);
+    try walkExpressions(w, for_node.ast.inputs);
     try walkExpression(w, for_node.ast.then_expr);
     if (for_node.ast.else_expr.unwrap()) |else_expr| {
         try walkExpression(w, else_expr);
@@ -874,15 +878,12 @@ fn walkIf(w: *Walk, node_index: Ast.Node.Index, if_node: Ast.full.If) Error!void
 
 fn walkAsm(w: *Walk, asm_node: Ast.full.Asm) Error!void {
     try walkExpression(w, asm_node.ast.template);
-    for (asm_node.ast.items) |item| {
-        try walkExpression(w, item);
-    }
+    try walkExpressions(w, asm_node.ast.items);
 }
 
-fn walkParamList(w: *Walk, params: []const Ast.Node.Index) Error!void {
-    for (params) |param_node| {
-        try walkExpression(w, param_node);
-    }
+fn walkAsmLegacy(w: *Walk, asm_node: Ast.full.AsmLegacy) Error!void {
+    try walkExpression(w, asm_node.ast.template);
+    try walkExpressions(w, asm_node.ast.items);
 }
 
 /// Check if it is already gutted (i.e. its body replaced with `@trap()`).

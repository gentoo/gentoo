Backports to fix py3.11 tests (and one to replace deprecated cgi library)

Upstream: https://code.djangoproject.com/ticket/33173

Includes:

https://code.djangoproject.com/changeset/fac3dd7f390d372736e05974cc5c3ef1a3768fbb
https://code.djangoproject.com/changeset/d4fd31684ad5a7b9be8a9d26c5a8796f96c8d80b
https://code.djangoproject.com/changeset/2ee4caf56b8e000cabbb73ad81ff05738d6d0a35
https://code.djangoproject.com/changeset/439cd73c1670a2af25837149a68526fe5555399d
https://code.djangoproject.com/changeset/441103a04d1d167dc870eaaf90e3fba974f67c93
https://code.djangoproject.com/changeset/34e2148fc725e7200050f74130d7523e3cd8507a

--- a/django/core/handlers/asgi.py
+++ b/django/core/handlers/asgi.py
@@ -164,12 +164,15 @@ class ASGIHandler(base.BaseHandler):
         except RequestAborted:
             return
         # Request is complete and can be served.
-        set_script_prefix(self.get_script_prefix(scope))
-        await sync_to_async(signals.request_started.send, thread_sensitive=True)(
-            sender=self.__class__, scope=scope
-        )
-        # Get the request and check for basic issues.
-        request, error_response = self.create_request(scope, body_file)
+        try:
+            set_script_prefix(self.get_script_prefix(scope))
+            await sync_to_async(signals.request_started.send, thread_sensitive=True)(
+                sender=self.__class__, scope=scope
+            )
+            # Get the request and check for basic issues.
+            request, error_response = self.create_request(scope, body_file)
+        finally:
+            body_file.close()
         if request is None:
             await self.send_response(error_response, send)
             return
@@ -192,6 +195,7 @@ class ASGIHandler(base.BaseHandler):
         while True:
             message = await receive()
             if message["type"] == "http.disconnect":
+                body_file.close()
                 # Early client disconnect.
                 raise RequestAborted()
             # Add a body chunk from the message, if provided.
--- a/django/core/management/templates.py
+++ b/django/core/management/templates.py
@@ -1,5 +1,4 @@
 import argparse
-import cgi
 import mimetypes
 import os
 import posixpath
@@ -15,6 +14,7 @@ from django.core.management.base import BaseCommand, CommandError
 from django.core.management.utils import handle_extensions
 from django.template import Context, Engine
 from django.utils import archive
+from django.utils.http import parse_header_parameters
 from django.utils.version import get_docs_version
 
 
@@ -317,7 +317,7 @@ class TemplateCommand(BaseCommand):
         # Trying to get better name from response headers
         content_disposition = info.get("content-disposition")
         if content_disposition:
-            _, params = cgi.parse_header(content_disposition)
+            _, params = parse_header_parameters(content_disposition)
             guessed_filename = params.get("filename") or used_name
         else:
             guessed_filename = used_name
--- a/django/http/multipartparser.py
+++ b/django/http/multipartparser.py
@@ -6,7 +6,6 @@ file upload handlers for processing.
 """
 import base64
 import binascii
-import cgi
 import collections
 import html
 from urllib.parse import unquote
@@ -20,6 +19,7 @@ from django.core.exceptions import (
 from django.core.files.uploadhandler import SkipFile, StopFutureHandlers, StopUpload
 from django.utils.datastructures import MultiValueDict
 from django.utils.encoding import force_str
+from django.utils.regex_helper import _lazy_re_compile
 
 __all__ = ("MultiPartParser", "MultiPartParserError", "InputStreamExhausted")
 
@@ -49,6 +49,8 @@ class MultiPartParser:
     and returns a tuple of ``(MultiValueDict(POST), MultiValueDict(FILES))``.
     """
 
+    boundary_re = _lazy_re_compile(rb"[ -~]{0,200}[!-~]")
+
     def __init__(self, META, input_data, upload_handlers, encoding=None):
         """
         Initialize the MultiPartParser object.
@@ -77,7 +79,7 @@ class MultiPartParser:
                 % force_str(content_type)
             )
         boundary = opts.get("boundary")
-        if not boundary or not cgi.valid_boundary(boundary):
+        if not boundary or not self.boundary_re.fullmatch(boundary):
             raise MultiPartParserError(
                 "Invalid boundary in multipart: %s" % force_str(boundary)
             )
--- a/django/http/request.py
+++ b/django/http/request.py
@@ -1,4 +1,3 @@
-import cgi
 import codecs
 import copy
 from io import BytesIO
@@ -22,7 +21,7 @@ from django.utils.datastructures import (
 )
 from django.utils.encoding import escape_uri_path, iri_to_uri
 from django.utils.functional import cached_property
-from django.utils.http import is_same_domain
+from django.utils.http import is_same_domain, parse_header_parameters
 from django.utils.regex_helper import _lazy_re_compile
 
 from .multipartparser import parse_header
@@ -97,7 +96,7 @@ class HttpRequest:
 
     def _set_content_type_params(self, meta):
         """Set content_type, content_params, and encoding."""
-        self.content_type, self.content_params = cgi.parse_header(
+        self.content_type, self.content_params = parse_header_parameters(
             meta.get("CONTENT_TYPE", "")
         )
         if "charset" in self.content_params:
--- a/django/utils/encoding.py
+++ b/django/utils/encoding.py
@@ -249,12 +249,12 @@ def filepath_to_uri(path):
 
 def get_system_encoding():
     """
-    The encoding of the default system locale. Fallback to 'ascii' if the
+    The encoding for the character type functions. Fallback to 'ascii' if the
     #encoding is unsupported by Python or could not be determined. See tickets
     #10335 and #5846.
     """
     try:
-        encoding = locale.getdefaultlocale()[1] or "ascii"
+        encoding = locale.getlocale()[1] or "ascii"
         codecs.lookup(encoding)
     except Exception:
         encoding = "ascii"
--- a/django/utils/http.py
+++ b/django/utils/http.py
@@ -366,3 +366,36 @@ def escape_leading_slashes(url):
     if url.startswith("//"):
         url = "/%2F{}".format(url[2:])
     return url
+
+
+def _parseparam(s):
+    while s[:1] == ";":
+        s = s[1:]
+        end = s.find(";")
+        while end > 0 and (s.count('"', 0, end) - s.count('\\"', 0, end)) % 2:
+            end = s.find(";", end + 1)
+        if end < 0:
+            end = len(s)
+        f = s[:end]
+        yield f.strip()
+        s = s[end:]
+
+
+def parse_header_parameters(line):
+    """
+    Parse a Content-type like header.
+    Return the main content-type and a dictionary of options.
+    """
+    parts = _parseparam(";" + line)
+    key = parts.__next__()
+    pdict = {}
+    for p in parts:
+        i = p.find("=")
+        if i >= 0:
+            name = p[:i].strip().lower()
+            value = p[i + 1 :].strip()
+            if len(value) >= 2 and value[0] == value[-1] == '"':
+                value = value[1:-1]
+                value = value.replace("\\\\", "\\").replace('\\"', '"')
+            pdict[name] = value
+    return key, pdict
--- a/django/utils/version.py
+++ b/django/utils/version.py
@@ -15,6 +15,7 @@ PY37 = sys.version_info >= (3, 7)
 PY38 = sys.version_info >= (3, 8)
 PY39 = sys.version_info >= (3, 9)
 PY310 = sys.version_info >= (3, 10)
+PY311 = sys.version_info >= (3, 11)
 
 
 def get_version(version=None):
--- a/tests/mail/tests.py
+++ b/tests/mail/tests.py
@@ -29,6 +29,7 @@ from django.core.mail.message import BadHeaderError, sanitize_address
 from django.test import SimpleTestCase, override_settings
 from django.test.utils import requires_tz_support
 from django.utils.translation import gettext_lazy
+from django.utils.version import PY311
 
 try:
     from aiosmtpd.controller import Controller
@@ -790,7 +791,7 @@ class MailTests(HeadersCheckMixin, SimpleTestCase):
                 filebased.EmailBackend,
             )
 
-        if sys.platform == "win32":
+        if sys.platform == "win32" and not PY311:
             msg = (
                 "_getfullpathname: path should be string, bytes or os.PathLike, not "
                 "object"
--- a/tests/test_runner/test_debug_sql.py
+++ b/tests/test_runner/test_debug_sql.py
@@ -4,6 +4,7 @@ from io import StringIO
 from django.db import connection
 from django.test import TestCase
 from django.test.runner import DiscoverRunner
+from django.utils.version import PY311
 
 from .models import Person
 
@@ -109,14 +110,17 @@ class TestDebugSQL(unittest.TestCase):
         ),
     ]
 
+    # Python 3.11 uses fully qualified test name in the output.
+    method_name = ".runTest" if PY311 else ""
+    test_class_path = "test_runner.test_debug_sql.TestDebugSQL"
     verbose_expected_outputs = [
-        "runTest (test_runner.test_debug_sql.TestDebugSQL.FailingTest) ... FAIL",
-        "runTest (test_runner.test_debug_sql.TestDebugSQL.ErrorTest) ... ERROR",
-        "runTest (test_runner.test_debug_sql.TestDebugSQL.PassingTest) ... ok",
+        f"runTest ({test_class_path}.FailingTest{method_name}) ... FAIL",
+        f"runTest ({test_class_path}.ErrorTest{method_name}) ... ERROR",
+        f"runTest ({test_class_path}.PassingTest{method_name}) ... ok",
         # If there are errors/failures in subtests but not in test itself,
         # the status is not written. That behavior comes from Python.
-        "runTest (test_runner.test_debug_sql.TestDebugSQL.FailingSubTest) ...",
-        "runTest (test_runner.test_debug_sql.TestDebugSQL.ErrorSubTest) ...",
+        f"runTest ({test_class_path}.FailingSubTest{method_name}) ...",
+        f"runTest ({test_class_path}.ErrorSubTest{method_name}) ...",
         (
             """SELECT COUNT(*) AS "__count" """
             """FROM "test_runner_person" WHERE """
--- a/tests/test_runner/test_parallel.py
+++ b/tests/test_runner/test_parallel.py
@@ -4,6 +4,7 @@ import unittest
 
 from django.test import SimpleTestCase
 from django.test.runner import RemoteTestResult
+from django.utils.version import PY311
 
 try:
     import tblib.pickling_support
@@ -125,7 +126,9 @@ class RemoteTestResultTest(SimpleTestCase):
         self.assertEqual(event[0], "addSubTest")
         self.assertEqual(
             str(event[2]),
-            "dummy_test (test_runner.test_parallel.SampleFailingSubtest) (index=0)",
+            "dummy_test (test_runner.test_parallel.SampleFailingSubtest%s) (index=0)"
+            # Python 3.11 uses fully qualified test name in the output.
+            % (".dummy_test" if PY311 else ""),
         )
         self.assertEqual(repr(event[3][1]), "AssertionError('0 != 1')")
 
--- a/tests/test_utils/tests.py
+++ b/tests/test_utils/tests.py
@@ -47,6 +47,7 @@ from django.test.utils import (
 from django.urls import NoReverseMatch, path, reverse, reverse_lazy
 from django.utils.deprecation import RemovedInDjango41Warning
 from django.utils.log import DEFAULT_LOGGING
+from django.utils.version import PY311
 
 from .models import Car, Person, PossessedCar
 from .views import empty_response
@@ -99,9 +100,11 @@ class SkippingTestCase(SimpleTestCase):
             SkipTestCase("test_foo").test_foo,
             ValueError,
             "skipUnlessDBFeature cannot be used on test_foo (test_utils.tests."
-            "SkippingTestCase.test_skip_unless_db_feature.<locals>.SkipTestCase) "
+            "SkippingTestCase.test_skip_unless_db_feature.<locals>.SkipTestCase%s) "
             "as SkippingTestCase.test_skip_unless_db_feature.<locals>.SkipTestCase "
-            "doesn't allow queries against the 'default' database.",
+            "doesn't allow queries against the 'default' database."
+            # Python 3.11 uses fully qualified test name in the output.
+            % (".test_foo" if PY311 else ""),
         )
 
     def test_skip_if_db_feature(self):
@@ -144,9 +147,11 @@ class SkippingTestCase(SimpleTestCase):
             SkipTestCase("test_foo").test_foo,
             ValueError,
             "skipIfDBFeature cannot be used on test_foo (test_utils.tests."
-            "SkippingTestCase.test_skip_if_db_feature.<locals>.SkipTestCase) "
+            "SkippingTestCase.test_skip_if_db_feature.<locals>.SkipTestCase%s) "
             "as SkippingTestCase.test_skip_if_db_feature.<locals>.SkipTestCase "
-            "doesn't allow queries against the 'default' database.",
+            "doesn't allow queries against the 'default' database."
+            # Python 3.11 uses fully qualified test name in the output.
+            % (".test_foo" if PY311 else ""),
         )
 
 
--- a/tests/utils_tests/test_dateparse.py
+++ b/tests/utils_tests/test_dateparse.py
@@ -8,6 +8,7 @@ from django.utils.dateparse import (
     parse_time,
 )
 from django.utils.timezone import get_fixed_timezone
+from django.utils.version import PY311
 
 
 class DateParseTests(unittest.TestCase):
@@ -15,14 +16,18 @@ class DateParseTests(unittest.TestCase):
         # Valid inputs
         self.assertEqual(parse_date("2012-04-23"), date(2012, 4, 23))
         self.assertEqual(parse_date("2012-4-9"), date(2012, 4, 9))
+        if PY311:
+            self.assertEqual(parse_date("20120423"), date(2012, 4, 23))
         # Invalid inputs
-        self.assertIsNone(parse_date("20120423"))
+        self.assertIsNone(parse_date("2012423"))
         with self.assertRaises(ValueError):
             parse_date("2012-04-56")
 
     def test_parse_time(self):
         # Valid inputs
         self.assertEqual(parse_time("09:15:00"), time(9, 15))
+        if PY311:
+            self.assertEqual(parse_time("091500"), time(9, 15))
         self.assertEqual(parse_time("10:10"), time(10, 10))
         self.assertEqual(parse_time("10:20:30.400"), time(10, 20, 30, 400000))
         self.assertEqual(parse_time("10:20:30,400"), time(10, 20, 30, 400000))
@@ -35,7 +40,7 @@ class DateParseTests(unittest.TestCase):
         self.assertIsNone(parse_time("00:05:23+"))
         self.assertIsNone(parse_time("00:05:23+25:00"))
         self.assertIsNone(parse_time("4:18:101"))
-        self.assertIsNone(parse_time("091500"))
+        self.assertIsNone(parse_time("91500"))
         with self.assertRaises(ValueError):
             parse_time("09:15:90")
 
--- a/tests/utils_tests/test_encoding.py
+++ b/tests/utils_tests/test_encoding.py
@@ -106,7 +106,7 @@ class TestEncodingUtils(SimpleTestCase):
         self.assertEqual(smart_str("foo"), "foo")
 
     def test_get_default_encoding(self):
-        with mock.patch("locale.getdefaultlocale", side_effect=Exception):
+        with mock.patch("locale.getlocale", side_effect=Exception):
             self.assertEqual(get_system_encoding(), "ascii")
 
     def test_repercent_broken_unicode_recursion_error(self):
--- a/tests/utils_tests/test_http.py
+++ b/tests/utils_tests/test_http.py
@@ -12,6 +12,7 @@ from django.utils.http import (
     int_to_base36,
     is_same_domain,
     parse_etags,
+    parse_header_parameters,
     parse_http_date,
     quote_etag,
     url_has_allowed_host_and_scheme,
@@ -428,3 +429,39 @@ class EscapeLeadingSlashesTests(unittest.TestCase):
         for url, expected in tests:
             with self.subTest(url=url):
                 self.assertEqual(escape_leading_slashes(url), expected)
+
+
+class ParseHeaderParameterTests(unittest.TestCase):
+    def test_basic(self):
+        tests = [
+            ("text/plain", ("text/plain", {})),
+            ("text/vnd.just.made.this.up ; ", ("text/vnd.just.made.this.up", {})),
+            ("text/plain;charset=us-ascii", ("text/plain", {"charset": "us-ascii"})),
+            (
+                'text/plain ; charset="us-ascii"',
+                ("text/plain", {"charset": "us-ascii"}),
+            ),
+            (
+                'text/plain ; charset="us-ascii"; another=opt',
+                ("text/plain", {"charset": "us-ascii", "another": "opt"}),
+            ),
+            (
+                'attachment; filename="silly.txt"',
+                ("attachment", {"filename": "silly.txt"}),
+            ),
+            (
+                'attachment; filename="strange;name"',
+                ("attachment", {"filename": "strange;name"}),
+            ),
+            (
+                'attachment; filename="strange;name";size=123;',
+                ("attachment", {"filename": "strange;name", "size": "123"}),
+            ),
+            (
+                'form-data; name="files"; filename="fo\\"o;bar"',
+                ("form-data", {"name": "files", "filename": 'fo"o;bar'}),
+            ),
+        ]
+        for header, expected in tests:
+            with self.subTest(header=header):
+                self.assertEqual(parse_header_parameters(header), expected)

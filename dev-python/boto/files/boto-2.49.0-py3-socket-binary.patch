https://github.com/boto/boto/commit/d2cb697b32c297858ecc36701a5a4176818ab36d
https://github.com/boto/boto/pull/2718
https://github.com/boto/boto/pull/2893
https://github.com/boto/boto/pull/3699

From d2cb697b32c297858ecc36701a5a4176818ab36d Mon Sep 17 00:00:00 2001
From: Cat Lee Ball <cball@google.com>
Date: Mon, 10 Jun 2019 13:31:11 -0700
Subject: [PATCH] Ensure binary strings sent to socket

When running pre-release tests with proxied connections, it appeared a
few spots in connection.py would fail under Python 3 since the
socket.sendall method expects binary strings rather than unicode.
---
 boto/connection.py | 13 +++++++------
 1 file changed, 7 insertions(+), 6 deletions(-)

diff --git a/boto/connection.py b/boto/connection.py
index a0d89a51f49c..d084d1f881fb 100644
--- a/boto/connection.py
+++ b/boto/connection.py
@@ -796,17 +796,17 @@ class AWSAuthConnection(object):
         else:
             sock = socket.create_connection((self.proxy, int(self.proxy_port)))
         boto.log.debug("Proxy connection: CONNECT %s HTTP/1.0\r\n", host)
-        sock.sendall("CONNECT %s HTTP/1.0\r\n" % host)
-        sock.sendall("User-Agent: %s\r\n" % UserAgent)
+        sock.sendall(six.ensure_binary("CONNECT %s HTTP/1.0\r\n" % host))
+        sock.sendall(six.ensure_binary("User-Agent: %s\r\n" % UserAgent))
         if self.proxy_user and self.proxy_pass:
             for k, v in self.get_proxy_auth_header().items():
-                sock.sendall("%s: %s\r\n" % (k, v))
+                sock.sendall(six.ensure_binary("%s: %s\r\n" % (k, v)))
             # See discussion about this config option at
             # https://groups.google.com/forum/?fromgroups#!topic/boto-dev/teenFvOq2Cc
             if config.getbool('Boto', 'send_crlf_after_proxy_auth_headers', False):
-                sock.sendall("\r\n")
+                sock.sendall(six.ensure_binary("\r\n"))
         else:
-            sock.sendall("\r\n")
+            sock.sendall(six.ensure_binary("\r\n"))
         resp = http_client.HTTPResponse(sock, strict=True, debuglevel=self.debug)
         resp.begin()
 
@@ -814,9 +814,10 @@ class AWSAuthConnection(object):
             # Fake a socket error, use a code that make it obvious it hasn't
             # been generated by the socket library
             raise socket.error(-71,
+                               six.ensure_binary(
                                "Error talking to HTTP proxy %s:%s: %s (%s)" %
                                (self.proxy, self.proxy_port,
-                                resp.status, resp.reason))
+                                resp.status, resp.reason)))
 
         # We can safely close the response, it duped the original socket
         resp.close()
-- 
2.28.0


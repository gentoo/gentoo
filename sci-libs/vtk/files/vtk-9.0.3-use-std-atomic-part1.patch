This is a bit packported upstream commit patch, that removes vtkAtomic
and switches codebase to use std::atomic. This patch is kinda required
for patchset for supporting modern versions of dev-cpp/tbb.

Patch backported by Vadim Misbakh-Solovov <mva@gentoo.org>

Original patch url: https://gitlab.kitware.com/vtk/vtk/-/commit/4ca62d8c73.patch

--- a/Common/Core/CMakeLists.txt
+++ b/Common/Core/CMakeLists.txt
@@ -266,7 +266,6 @@ set(headers
   vtkArchiver.h
   vtkArrayIteratorIncludes.h
   vtkAssume.h
-  vtkAtomicTypeConcepts.h
   vtkAutoInit.h
   vtkBuffer.h
   vtkCollectionRange.h
--- a/Common/Core/SMP/OpenMP/vtkAtomic.cxx
+++ /dev/null
@@ -1,173 +0,0 @@
-/*=========================================================================
-
-  Program:   Visualization Toolkit
-  Module:    vtkAtomic.cxx
-
-  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
-  All rights reserved.
-  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.
-
-     This software is distributed WITHOUT ANY WARRANTY; without even
-     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-     PURPOSE.  See the above copyright notice for more information.
-
-=========================================================================*/
-
-#include "vtkAtomic.h"
-
-namespace detail
-{
-
-vtkTypeInt64 AtomicOps<8>::AddAndFetch(vtkTypeInt64* ref, vtkTypeInt64 val)
-{
-  vtkTypeInt64 result;
-#pragma omp atomic capture
-  {
-    (*ref) += val;
-    result = *ref;
-  }
-#pragma omp flush
-  return result;
-}
-
-vtkTypeInt64 AtomicOps<8>::SubAndFetch(vtkTypeInt64* ref, vtkTypeInt64 val)
-{
-  vtkTypeInt64 result;
-#pragma omp atomic capture
-  {
-    (*ref) -= val;
-    result = *ref;
-  }
-#pragma omp flush
-  return result;
-}
-
-vtkTypeInt64 AtomicOps<8>::PreIncrement(vtkTypeInt64* ref)
-{
-  vtkTypeInt64 result;
-#pragma omp atomic capture
-  result = ++(*ref);
-#pragma omp flush
-  return result;
-}
-
-vtkTypeInt64 AtomicOps<8>::PreDecrement(vtkTypeInt64* ref)
-{
-  vtkTypeInt64 result;
-#pragma omp atomic capture
-  result = --(*ref);
-#pragma omp flush
-  return result;
-}
-
-vtkTypeInt64 AtomicOps<8>::PostIncrement(vtkTypeInt64* ref)
-{
-  vtkTypeInt64 result;
-#pragma omp atomic capture
-  result = (*ref)++;
-#pragma omp flush
-  return result;
-}
-
-vtkTypeInt64 AtomicOps<8>::PostDecrement(vtkTypeInt64* ref)
-{
-  vtkTypeInt64 result;
-#pragma omp atomic capture
-  result = (*ref)--;
-#pragma omp flush
-  return result;
-}
-
-vtkTypeInt64 AtomicOps<8>::Load(const vtkTypeInt64* ref)
-{
-  vtkTypeInt64 result;
-#pragma omp flush
-#pragma omp atomic read
-  result = *ref;
-  return result;
-}
-
-void AtomicOps<8>::Store(vtkTypeInt64* ref, vtkTypeInt64 val)
-{
-#pragma omp atomic write
-  *ref = val;
-#pragma omp flush
-}
-
-vtkTypeInt32 AtomicOps<4>::AddAndFetch(vtkTypeInt32* ref, vtkTypeInt32 val)
-{
-  vtkTypeInt32 result;
-#pragma omp atomic capture
-  {
-    (*ref) += val;
-    result = *ref;
-  }
-#pragma omp flush
-  return result;
-}
-
-vtkTypeInt32 AtomicOps<4>::SubAndFetch(vtkTypeInt32* ref, vtkTypeInt32 val)
-{
-  vtkTypeInt32 result;
-#pragma omp atomic capture
-  {
-    (*ref) -= val;
-    result = *ref;
-  }
-#pragma omp flush
-  return result;
-}
-
-vtkTypeInt32 AtomicOps<4>::PreIncrement(vtkTypeInt32* ref)
-{
-  vtkTypeInt32 result;
-#pragma omp atomic capture
-  result = ++(*ref);
-#pragma omp flush
-  return result;
-}
-
-vtkTypeInt32 AtomicOps<4>::PreDecrement(vtkTypeInt32* ref)
-{
-  vtkTypeInt32 result;
-#pragma omp atomic capture
-  result = --(*ref);
-#pragma omp flush
-  return result;
-}
-
-vtkTypeInt32 AtomicOps<4>::PostIncrement(vtkTypeInt32* ref)
-{
-  vtkTypeInt32 result;
-#pragma omp atomic capture
-  result = (*ref)++;
-#pragma omp flush
-  return result;
-}
-
-vtkTypeInt32 AtomicOps<4>::PostDecrement(vtkTypeInt32* ref)
-{
-  vtkTypeInt32 result;
-#pragma omp atomic capture
-  result = (*ref)--;
-#pragma omp flush
-  return result;
-}
-
-vtkTypeInt32 AtomicOps<4>::Load(const vtkTypeInt32* ref)
-{
-  vtkTypeInt32 result;
-#pragma omp flush
-#pragma omp atomic read
-  result = *ref;
-  return result;
-}
-
-void AtomicOps<4>::Store(vtkTypeInt32* ref, vtkTypeInt32 val)
-{
-#pragma omp atomic write
-  *ref = val;
-#pragma omp flush
-}
-
-}
--- a/Common/Core/SMP/OpenMP/vtkAtomic.h.in
+++ /dev/null
@@ -1,293 +0,0 @@
-/*=========================================================================
-
-  Program:   Visualization Toolkit
-  Module:    vtkAtomic.h
-
-  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
-  All rights reserved.
-  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.
-
-     This software is distributed WITHOUT ANY WARRANTY; without even
-     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-     PURPOSE.  See the above copyright notice for more information.
-
-=========================================================================*/
-// .NAME vtkAtomic -
-// .SECTION Description
-
-#ifndef vtkAtomic_h
-#define vtkAtomic_h
-
-#include "vtkCommonCoreModule.h" // For export macro
-#include "vtkAtomicTypeConcepts.h"
-#include "vtkSystemIncludes.h"
-
-#include <cstddef>
-
-
-#ifndef __VTK_WRAP__
-namespace detail
-{
-
-template <size_t size> class AtomicOps;
-
-template <> class VTKCOMMONCORE_EXPORT AtomicOps<8>
-{
-public:
-  typedef vtkTypeInt64 atomic_type;
-
-  static vtkTypeInt64 AddAndFetch(vtkTypeInt64 *ref, vtkTypeInt64 val);
-  static vtkTypeInt64 SubAndFetch(vtkTypeInt64 *ref, vtkTypeInt64 val);
-  static vtkTypeInt64 PreIncrement(vtkTypeInt64 *ref);
-  static vtkTypeInt64 PreDecrement(vtkTypeInt64 *ref);
-  static vtkTypeInt64 PostIncrement(vtkTypeInt64 *ref);
-  static vtkTypeInt64 PostDecrement(vtkTypeInt64 *ref);
-  static vtkTypeInt64 Load(const vtkTypeInt64 *ref);
-  static void Store(vtkTypeInt64 *ref, vtkTypeInt64 val);
-};
-
-template <> class VTKCOMMONCORE_EXPORT AtomicOps<4>
-{
-public:
-  typedef vtkTypeInt32 atomic_type;
-
-  static vtkTypeInt32 AddAndFetch(vtkTypeInt32 *ref, vtkTypeInt32 val);
-  static vtkTypeInt32 SubAndFetch(vtkTypeInt32 *ref, vtkTypeInt32 val);
-  static vtkTypeInt32 PreIncrement(vtkTypeInt32 *ref);
-  static vtkTypeInt32 PreDecrement(vtkTypeInt32 *ref);
-  static vtkTypeInt32 PostIncrement(vtkTypeInt32 *ref);
-  static vtkTypeInt32 PostDecrement(vtkTypeInt32 *ref);
-  static vtkTypeInt32 Load(const vtkTypeInt32 *ref);
-  static void Store(vtkTypeInt32 *ref, vtkTypeInt32 val);
-};
-
-} // detail
-#endif // __VTK_WRAP__
-
-
-template <typename T> class vtkAtomic : private vtk::atomic::detail::IntegralType<T>
-{
-private:
-  typedef detail::AtomicOps<sizeof(T)> Impl;
-
-public:
-  vtkAtomic() : Atomic(0)
-  {
-  }
-
-  vtkAtomic(T val) : Atomic(static_cast<typename Impl::atomic_type>(val))
-  {
-  }
-
-  vtkAtomic(const vtkAtomic<T> &atomic)
-    : Atomic(static_cast<typename Impl::atomic_type>(atomic.load()))
-  {
-  }
-
-  T operator++()
-  {
-    return static_cast<T>(Impl::PreIncrement(&this->Atomic));
-  }
-
-  T operator++(int)
-  {
-    return static_cast<T>(Impl::PostIncrement(&this->Atomic));
-  }
-
-  T operator--()
-  {
-    return static_cast<T>(Impl::PreDecrement(&this->Atomic));
-  }
-
-  T operator--(int)
-  {
-    return static_cast<T>(Impl::PostDecrement(&this->Atomic));
-  }
-
-  T operator+=(T val)
-  {
-    return static_cast<T>(Impl::AddAndFetch(&this->Atomic,
-      static_cast<typename Impl::atomic_type>(val)));
-  }
-
-  T operator-=(T val)
-  {
-    return static_cast<T>(Impl::SubAndFetch(&this->Atomic,
-      static_cast<typename Impl::atomic_type>(val)));
-  }
-
-  operator T() const
-  {
-    return static_cast<T>(Impl::Load(&this->Atomic));
-  }
-
-  T operator=(T val)
-  {
-    Impl::Store(&this->Atomic, static_cast<typename Impl::atomic_type>(val));
-    return val;
-  }
-
-  vtkAtomic<T>& operator=(const vtkAtomic<T> &atomic)
-  {
-    this->store(atomic.load());
-    return *this;
-  }
-
-  T load() const
-  {
-    return static_cast<T>(Impl::Load(&this->Atomic));
-  }
-
-  void store(T val)
-  {
-    Impl::Store(&this->Atomic, static_cast<typename Impl::atomic_type>(val));
-  }
-
-private:
-  typename Impl::atomic_type Atomic;
-};
-
-
-template <typename T> class vtkAtomic<T*>
-{
-private:
-  typedef detail::AtomicOps<sizeof(T*)> Impl;
-
-public:
-  vtkAtomic() : Atomic(0)
-  {
-  }
-
-  vtkAtomic(T* val)
-    : Atomic(reinterpret_cast<typename Impl::atomic_type>(val))
-  {
-  }
-
-  vtkAtomic(const vtkAtomic<T*> &atomic)
-    : Atomic(reinterpret_cast<typename Impl::atomic_type>(atomic.load()))
-  {
-  }
-
-  T* operator++()
-  {
-    return reinterpret_cast<T*>(Impl::AddAndFetch(&this->Atomic, sizeof(T)));
-  }
-
-  T* operator++(int)
-  {
-    T* val = reinterpret_cast<T*>(Impl::AddAndFetch(&this->Atomic, sizeof(T)));
-    return --val;
-  }
-
-  T* operator--()
-  {
-    return reinterpret_cast<T*>(Impl::SubAndFetch(&this->Atomic, sizeof(T)));
-  }
-
-  T* operator--(int)
-  {
-    T* val = reinterpret_cast<T*>(Impl::AddAndFetch(&this->Atomic, sizeof(T)));
-    return ++val;
-  }
-
-  T* operator+=(std::ptrdiff_t val)
-  {
-    return reinterpret_cast<T*>(Impl::AddAndFetch(&this->Atomic,
-                                                  val * sizeof(T)));
-  }
-
-  T* operator-=(std::ptrdiff_t val)
-  {
-    return reinterpret_cast<T*>(Impl::SubAndFetch(&this->Atomic,
-                                                  val * sizeof(T)));
-  }
-
-  operator T*() const
-  {
-    return reinterpret_cast<T*>(Impl::Load(&this->Atomic));
-  }
-
-  T* operator=(T* val)
-  {
-    Impl::Store(&this->Atomic,
-                reinterpret_cast<typename Impl::atomic_type>(val));
-    return val;
-  }
-
-  vtkAtomic<T*>& operator=(const vtkAtomic<T*> &atomic)
-  {
-    this->store(atomic.load());
-    return *this;
-  }
-
-  T* load() const
-  {
-    return reinterpret_cast<T*>(Impl::Load(&this->Atomic));
-  }
-
-  void store(T* val)
-  {
-    Impl::Store(&this->Atomic,
-                reinterpret_cast<typename Impl::atomic_type>(val));
-  }
-
-private:
-  typename Impl::atomic_type Atomic;
-};
-
-
-template <> class vtkAtomic<void*>
-{
-private:
-  typedef detail::AtomicOps<sizeof(void*)> Impl;
-
-public:
-  vtkAtomic() : Atomic(0)
-  {
-  }
-
-  vtkAtomic(void* val)
-    : Atomic(reinterpret_cast<Impl::atomic_type>(val))
-  {
-  }
-
-  vtkAtomic(const vtkAtomic<void*> &atomic)
-    : Atomic(reinterpret_cast<Impl::atomic_type>(atomic.load()))
-  {
-  }
-
-  operator void*() const
-  {
-    return reinterpret_cast<void*>(Impl::Load(&this->Atomic));
-  }
-
-  void* operator=(void* val)
-  {
-    Impl::Store(&this->Atomic,
-                reinterpret_cast<Impl::atomic_type>(val));
-    return val;
-  }
-
-  vtkAtomic<void*>& operator=(const vtkAtomic<void*> &atomic)
-  {
-    this->store(atomic.load());
-    return *this;
-  }
-
-  void* load() const
-  {
-    return reinterpret_cast<void*>(Impl::Load(&this->Atomic));
-  }
-
-  void store(void* val)
-  {
-    Impl::Store(&this->Atomic,
-                reinterpret_cast<Impl::atomic_type>(val));
-  }
-
-private:
-  Impl::atomic_type Atomic;
-};
-
-#endif
-// VTK-HeaderTest-Exclude: vtkAtomic.h
--- a/Common/Core/SMP/OpenMP/vtkSMPThreadLocalImpl.h.in
+++ b/Common/Core/SMP/OpenMP/vtkSMPThreadLocalImpl.h.in
@@ -33,7 +33,6 @@
 #define vtkSMPThreadLocalImpl_h
 
 #include "vtkCommonCoreModule.h" // For export macro
-#include "vtkAtomic.h"
 #include "vtkConfigure.h"
 #include "vtkSystemIncludes.h"
 
 #include <atomic>
@@ -49,7 +49,7 @@ typedef void* StoragePointerType;
 
 struct Slot
 {
-  vtkAtomic<ThreadIdType> ThreadId;
+  std::atomic<ThreadIdType> ThreadId;
   omp_lock_t ModifyLock;
   StoragePointerType Storage;
 
@@ -66,7 +66,7 @@ private:
 struct HashTableArray
 {
   size_t Size, SizeLg;
-  vtkAtomic<size_t> NumberOfEntries;
+  std::atomic<size_t> NumberOfEntries;
   Slot *Slots;
   HashTableArray *Prev;
 
@@ -90,8 +90,8 @@ public:
   size_t Size() const;
 
 private:
-  vtkAtomic<HashTableArray*> Root;
-  vtkAtomic<size_t> Count;
+  std::atomic<HashTableArray*> Root;
+  std::atomic<size_t> Count;
 
   friend class ThreadSpecificStorageIterator;
 };
--- a/Common/Core/SMP/Sequential/vtkAtomic.cxx
+++ /dev/null
@@ -1,278 +0,0 @@
-/*=========================================================================
-
-  Program:   Visualization Toolkit
-  Module:    vtkAtomic.cxx
-
-  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
-  All rights reserved.
-  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.
-
-     This software is distributed WITHOUT ANY WARRANTY; without even
-     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-     PURPOSE.  See the above copyright notice for more information.
-
-=========================================================================*/
-
-#include "vtkAtomic.h"
-
-#if !defined(VTK_GCC_ATOMICS_32) && !defined(VTK_APPLE_ATOMICS_32) &&                              \
-  !defined(VTK_WINDOWS_ATOMICS_32)
-#define VTK_LOCK_BASED_ATOMICS_32
-#endif
-
-#if !defined(VTK_GCC_ATOMICS_64) && !defined(VTK_APPLE_ATOMICS_64) &&                              \
-  !defined(VTK_WINDOWS_ATOMICS_64)
-#define VTK_LOCK_BASED_ATOMICS_64
-#endif
-
-#if defined(VTK_WINDOWS_ATOMICS_32) || defined(VTK_WINDOWS_ATOMICS_64)
-#include "vtkWindows.h"
-#endif
-
-#if defined(VTK_LOCK_BASED_ATOMICS_32) || defined(VTK_LOCK_BASED_ATOMICS_64)
-
-#include "vtkSimpleCriticalSection.h"
-
-class CriticalSectionGuard
-{
-public:
-  CriticalSectionGuard(vtkSimpleCriticalSection& cs)
-    : CriticalSection(cs)
-  {
-    this->CriticalSection.Lock();
-  }
-
-  ~CriticalSectionGuard() { this->CriticalSection.Unlock(); }
-
-private:
-  // not copyable
-  CriticalSectionGuard(const CriticalSectionGuard&);
-  void operator=(const CriticalSectionGuard&);
-
-  vtkSimpleCriticalSection& CriticalSection;
-};
-
-#if defined(VTK_LOCK_BASED_ATOMICS_64)
-detail::AtomicOps<8>::atomic_type::atomic_type(vtkTypeInt64 init)
-  : var(init)
-{
-  this->csec = new vtkSimpleCriticalSection;
-}
-
-detail::AtomicOps<8>::atomic_type::~atomic_type()
-{
-  delete this->csec;
-}
-#endif
-
-#if defined(VTK_LOCK_BASED_ATOMICS_32)
-detail::AtomicOps<4>::atomic_type::atomic_type(vtkTypeInt32 init)
-  : var(init)
-{
-  this->csec = new vtkSimpleCriticalSection;
-}
-
-detail::AtomicOps<4>::atomic_type::~atomic_type()
-{
-  delete this->csec;
-}
-#endif
-
-#endif // VTK_LOCK_BASED_ATOMICS
-
-namespace detail
-{
-
-#if defined(VTK_WINDOWS_ATOMICS_64) || defined(VTK_LOCK_BASED_ATOMICS_64)
-
-vtkTypeInt64 AtomicOps<8>::AddAndFetch(atomic_type* ref, vtkTypeInt64 val)
-{
-#if defined(VTK_WINDOWS_ATOMICS_64)
-#if defined(VTK_HAS_INTERLOCKEDADD)
-  return InterlockedAdd64(ref, val);
-#else
-  return InterlockedExchangeAdd64(ref, val) + val;
-#endif
-#else
-  CriticalSectionGuard csg(*ref->csec);
-  return ref->var += val;
-#endif
-}
-
-vtkTypeInt64 AtomicOps<8>::SubAndFetch(atomic_type* ref, vtkTypeInt64 val)
-{
-#if defined(VTK_WINDOWS_ATOMICS_64)
-#if defined(VTK_HAS_INTERLOCKEDADD)
-  return InterlockedAdd64(ref, -val);
-#else
-  return InterlockedExchangeAdd64(ref, -val) - val;
-#endif
-#else
-  CriticalSectionGuard csg(*ref->csec);
-  return ref->var -= val;
-#endif
-}
-
-vtkTypeInt64 AtomicOps<8>::PreIncrement(atomic_type* ref)
-{
-#if defined(VTK_WINDOWS_ATOMICS_64)
-  return InterlockedIncrement64(ref);
-#else
-  CriticalSectionGuard csg(*ref->csec);
-  return ++(ref->var);
-#endif
-}
-
-vtkTypeInt64 AtomicOps<8>::PreDecrement(atomic_type* ref)
-{
-#if defined(VTK_WINDOWS_ATOMICS_64)
-  return InterlockedDecrement64(ref);
-#else
-  CriticalSectionGuard csg(*ref->csec);
-  return --(ref->var);
-#endif
-}
-
-vtkTypeInt64 AtomicOps<8>::PostIncrement(atomic_type* ref)
-{
-#if defined(VTK_WINDOWS_ATOMICS_64)
-  vtkTypeInt64 val = InterlockedIncrement64(ref);
-  return --val;
-#else
-  CriticalSectionGuard csg(*ref->csec);
-  return (ref->var)++;
-#endif
-}
-
-vtkTypeInt64 AtomicOps<8>::PostDecrement(atomic_type* ref)
-{
-#if defined(VTK_WINDOWS_ATOMICS_64)
-  vtkTypeInt64 val = InterlockedDecrement64(ref);
-  return ++val;
-#else
-  CriticalSectionGuard csg(*ref->csec);
-  return (ref->var)--;
-#endif
-}
-
-vtkTypeInt64 AtomicOps<8>::Load(const atomic_type* ref)
-{
-#if defined(VTK_WINDOWS_ATOMICS_64)
-  vtkTypeInt64 val;
-  InterlockedExchange64(&val, *ref);
-  return val;
-#else
-  CriticalSectionGuard csg(*ref->csec);
-  return ref->var;
-#endif
-}
-
-void AtomicOps<8>::Store(atomic_type* ref, vtkTypeInt64 val)
-{
-#if defined(VTK_WINDOWS_ATOMICS_64)
-  InterlockedExchange64(ref, val);
-#else
-  CriticalSectionGuard csg(*ref->csec);
-  ref->var = val;
-#endif
-}
-
-#endif // defined(VTK_WINDOWS_ATOMICS_64) || defined(VTK_LOCK_BASED_ATOMICS_64)
-
-#if defined(VTK_WINDOWS_ATOMICS_32) || defined(VTK_LOCK_BASED_ATOMICS_32)
-
-vtkTypeInt32 AtomicOps<4>::AddAndFetch(atomic_type* ref, vtkTypeInt32 val)
-{
-#if defined(VTK_WINDOWS_ATOMICS_32)
-#if defined(VTK_HAS_INTERLOCKEDADD)
-  return InterlockedAdd(reinterpret_cast<long*>(ref), val);
-#else
-  return InterlockedExchangeAdd(reinterpret_cast<long*>(ref), val) + val;
-#endif
-#else
-  CriticalSectionGuard csg(*ref->csec);
-  return ref->var += val;
-#endif
-}
-
-vtkTypeInt32 AtomicOps<4>::SubAndFetch(atomic_type* ref, vtkTypeInt32 val)
-{
-#if defined(VTK_WINDOWS_ATOMICS_32)
-#if defined(VTK_HAS_INTERLOCKEDADD)
-  return InterlockedAdd(reinterpret_cast<long*>(ref), -val);
-#else
-  return InterlockedExchangeAdd(reinterpret_cast<long*>(ref), -val) - val;
-#endif
-#else
-  CriticalSectionGuard csg(*ref->csec);
-  return ref->var -= val;
-#endif
-}
-
-vtkTypeInt32 AtomicOps<4>::PreIncrement(atomic_type* ref)
-{
-#if defined(VTK_WINDOWS_ATOMICS_32)
-  return InterlockedIncrement(reinterpret_cast<long*>(ref));
-#else
-  CriticalSectionGuard csg(*ref->csec);
-  return ++(ref->var);
-#endif
-}
-
-vtkTypeInt32 AtomicOps<4>::PreDecrement(atomic_type* ref)
-{
-#if defined(VTK_WINDOWS_ATOMICS_32)
-  return InterlockedDecrement(reinterpret_cast<long*>(ref));
-#else
-  CriticalSectionGuard csg(*ref->csec);
-  return --(ref->var);
-#endif
-}
-
-vtkTypeInt32 AtomicOps<4>::PostIncrement(atomic_type* ref)
-{
-#if defined(VTK_WINDOWS_ATOMICS_32)
-  vtkTypeInt32 val = InterlockedIncrement(reinterpret_cast<long*>(ref));
-  return --val;
-#else
-  CriticalSectionGuard csg(*ref->csec);
-  return (ref->var)++;
-#endif
-}
-
-vtkTypeInt32 AtomicOps<4>::PostDecrement(atomic_type* ref)
-{
-#if defined(VTK_WINDOWS_ATOMICS_32)
-  vtkTypeInt32 val = InterlockedDecrement(reinterpret_cast<long*>(ref));
-  return ++val;
-#else
-  CriticalSectionGuard csg(*ref->csec);
-  return (ref->var)--;
-#endif
-}
-
-vtkTypeInt32 AtomicOps<4>::Load(const atomic_type* ref)
-{
-#if defined(VTK_WINDOWS_ATOMICS_32)
-  long val;
-  InterlockedExchange(&val, *ref);
-  return val;
-#else
-  CriticalSectionGuard csg(*ref->csec);
-  return ref->var;
-#endif
-}
-
-void AtomicOps<4>::Store(atomic_type* ref, vtkTypeInt32 val)
-{
-#if defined(VTK_WINDOWS_ATOMICS_32)
-  InterlockedExchange(reinterpret_cast<long*>(ref), val);
-#else
-  CriticalSectionGuard csg(*ref->csec);
-  ref->var = val;
-#endif
-}
-
-#endif // defined(VTK_WINDOWS_ATOMICS_32) || defined(VTK_LOCK_BASED_ATOMICS_32)
-
-} // namespace detail
